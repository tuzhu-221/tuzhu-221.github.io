<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Transmon与谐振子耦合的JC模型</title>
    <link href="/2023/08/03/superconducting-qubits1/"/>
    <url>/2023/08/03/superconducting-qubits1/</url>
    
    <content type="html"><![CDATA[<h1 id="超导量子比特transmon与谐振腔的耦合jc模型">超导量子比特Transmon与谐振腔的耦合JC模型</h1><p>假如把比特截断到二能级，其与谐振腔相互耦合，则哈密顿量的写法：</p><p><span class="math display">\[\begin{equation}\begin{aligned}H = \hbar w_c \alpha^\dagger \alpha + \hbar w_q \frac{\sigma_z}{2} +\hbar g I_-\end{aligned}\end{equation}\]</span></p><p>其中 <span class="math inline">\(I_\pm = \alpha^+ \sigma^- \pm \alpha^- \sigma^+\)</span>，本note试图将这个耦合系统的哈密顿量主动变换到另一坐标系去，变换后的哈密顿量在原坐标系下对角，这个变换的表达式能够帮助我们找到系统在原坐标系的本征能级和本征态。</p><p>首先设算符 <span class="math inline">\(N_q = \left|1\right&gt;\left&lt;1\right|\otimes I + I \otimes \alpha^\dagger \alpha\)</span>， 第一项为比特激发态的投影算符，第二项为光腔的光子数算符，简单认为该算符是整个系统的激发光子数的计数算符。</p><p>首先证明<span class="math inline">\(N_q\)</span>算符与<span class="math inline">\(I_-\)</span>算符对易：</p><p><span class="math display">\[\begin{equation}\begin{aligned}[N_q,I_-]=&amp;[\left|1\right&gt;\left&lt;1\right|+ \alpha^\dagger \alpha, \alpha^\dagger \sigma^- - \alpha^- \sigma^+]\\ =&amp; \alpha^\dagger [\left|1\right&gt;\left&lt;1\right|,\sigma^-] -  \alpha[\left|1\right&gt;\left&lt;1\right|,\sigma^+] + [\alpha^\dagger\alpha,\alpha^\dagger]\sigma^--[\alpha^\dagger\alpha,\alpha]\sigma^+\\ =&amp; -\alpha^+ \sigma^- - \alpha^- \sigma^+ + \alpha^+ \sigma^- + \alpha^- \sigma^+ \\ =&amp; 0\end{aligned}\end{equation}\]</span></p><p>于是<span class="math inline">\(N_q\)</span>与<span class="math inline">\(I_-\)</span>对易，更进一步，简单扩展易知，其与哈密顿量<span class="math inline">\(H\)</span> 对易，所以 <span class="math inline">\(N_q\)</span> 在参与只含有 <span class="math inline">\(I_-\)</span> 与 <span class="math inline">\(H\)</span> 的对易式中时，由于换序的任意性，可以不特殊考虑，将其当作常数处理。</p><p>假设变换<span class="math inline">\(U = e^{- \varLambda{(N_q)}I_{-}}= e^{- D}\)</span>，其中<span class="math inline">\(\varLambda\)</span> 是算符<span class="math inline">\(N_q\)</span>的函数，简单容易证明<span class="math inline">\(U^{\dagger} =e^D\)</span> , 故该变换为幺正变换。</p><p>根据Hadamard引理：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;e^{\hat{A}}\hat{B}e^{-\hat{A}}\\=&amp;\sum_{n=0}^{\infty}\frac{1}{n!}\left[ ....\left( n \right) ....\left. \left[ \hat{A} \right. ,\left[ \hat{A},\hat{B} \right] \right] \right] \\=&amp;\sum_{n=0}^{\infty} \frac{1}{n!}C_A^n B\end{aligned}\end{equation}\]</span></p><p>这里第三行是对第二行对易式的简写，对哈密顿量<span class="math inline">\(H\)</span>以<span class="math inline">\(U\)</span>进行变换：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;U^\dagger H U \\=&amp; e^D H e^{-D}\\= &amp; \sum_{n=0}^{\infty} \frac{1}{n!} C^n_{D} H_0 + C^n_{D} \hbar g I_+\end{aligned}\end{equation}\]</span></p><p>由<span class="math inline">\([I_-,H_0] = \hbar (w_r-w_q) I_+= \hbar \Delta I_+\)</span>可将第一项写为<span class="math inline">\(H_0+\Delta \hbar \sum_{n=0}^{\infty}\frac{1}{(n+1)!}C^n_{\varLambda I_-}I^+\)</span>，于是原式写为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}U^\dagger H U =H_0+\Delta \hbar \sum_{n=0}^{\infty}\frac{(n+1)\hbar g +\hbar \Delta \varLambda}{(n+1)!}C^n_{\varLambda I_-}I^+\end{aligned}\end{equation}\]</span></p><p>此时需要计算<span class="math inline">\([I_-,I_+]\)</span>进一步化简：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;C^0_{\varLambda I_-}I^+ = I_+\end{aligned}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{aligned}C^1_{\varLambda I_-}I^+ &amp;= \varLambda [I_-,I_+]\\&amp;= \varLambda( 2[\alpha^+\sigma_{-},\alpha\sigma_{+}])\\&amp;= \varLambda( -2 \alpha^+\alpha \sigma_z - \sigma_{z} -1)\\&amp;= \varLambda( -2 \alpha^+\alpha \sigma_z - \sigma_{z} -\sigma_{z}^2)\\&amp;= \varLambda( -(2 \alpha^+\alpha +\sigma_z +1) \sigma_z)\\&amp;= \varLambda( -(2 \alpha^+\alpha +2 \left|1\right&gt;\left&lt;1\right|) \sigma_z)\\&amp; = -2 \varLambda N_q \sigma_z\end{aligned}\end{equation}\]</span></p><p>进一步的，由 <span class="math inline">\([\sigma_z,I_-] =-2 I_+\)</span>，最终得到表达式：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;C^{2n}_{\varLambda I_-}I^+ = \left(-4\right)^{n}\Lambda^{2n}N_{q}^{n}I_{+}\\&amp; C^{2n+1}_{\varLambda I_-}I^+ =  -2 \left(-4\right)^{n}\Lambda^{2n+1}N_{q}^{n+1}\sigma_z\end{aligned}\end{equation}\]</span></p><p>最终得到变换后的哈密顿量：</p><p><span class="math display">\[\begin{equation}\begin{aligned}H_D = H_0+ \hbar(\frac{\Delta\sin(2\Lambda\sqrt{N_{q}})}{2\sqrt{N_{q}}}+g\cos (2\Lambda\sqrt{N_{q}}))I_+\\+2\hbar N_q\sigma_z(\frac{g\sin(2\Lambda\sqrt{N_{q}})}{2\sqrt{N_{q}}}+\frac{\Delta(1-\cos (2\Lambda\sqrt{N_{q}}))}{4N_q})\end{aligned}\end{equation}\]</span></p><p>为了使得变换后的哈密顿量在原坐标系下对角，<span class="math inline">\(I_+\)</span>项应当为0，故得到<span class="math inline">\(\varLambda(N_q)\)</span>的表达式：</p><p><span class="math display">\[\begin{equation}\begin{aligned}\Lambda(N_{q})=\frac{-\arctan(2\lambda\sqrt{N_{q}})}{2\sqrt{N_{q}}}\end{aligned}\end{equation}\]</span></p><p>其中 <span class="math inline">\(\lambda = \frac{g}{\Delta}\)</span>，其下将使用该变换得到本征能级和本征态：</p><p><span class="math display">\[\begin{equation}\begin{aligned}U^\dagger H U \left|n,g\right&gt; &amp;= E_{n,g}\left|g,n\right&gt;\Rightarrow\\H(U\left|g,n\right&gt;) &amp;= E_n (U\left|g,n\right&gt;)\end{aligned}\end{equation}\]</span></p><p>则 <span class="math inline">\(H\)</span> 的本征值(借助<span class="math inline">\(H_D\)</span>原坐标系求解得)：</p><p><span class="math display">\[\begin{equation}\begin{aligned}H^{D}&amp;=H_{0}-\frac{\hbar\Delta}2\left(1-\sqrt{1+4\lambda^{2}N_{q}}\right)\sigma_{z}\\E_{g,n}&amp;=\hbar n\omega_{r}-\frac{\hbar}{2}\sqrt{\Delta^{2}+4g^{2}n}\\E_{e,n-1}&amp;=\hbar n\omega_{r}+\frac{\hbar}{2}\sqrt{\Delta^{2}+4g^{2}n}\end{aligned}\end{equation}\]</span></p><p><span class="math inline">\(H\)</span>的本征态求解，以<span class="math inline">\(\widetilde{\left|n,g\right&gt;} = U\left|n,g\right&gt;\)</span>为例：</p><p><span class="math display">\[\begin{equation}\begin{aligned}D\left|n,g\right&gt; &amp;= \frac{\arctan(2\lambda \sqrt N_q)}{2\sqrt N_q} I_- \left|n-1,e\right&gt;\\&amp;= \frac{\arctan(2\lambda \sqrt n)}{2\sqrt n} \sqrt{n} \left|n-1,e\right&gt;\\&amp; = \frac{\arctan(2\lambda \sqrt n)}{2} \left|n-1,e\right&gt;\\D\left|n,e\right&gt; &amp; = -\frac{\arctan(2\lambda \sqrt{n+1})}{2} \left|n+1,g\right&gt;\end{aligned}\end{equation}\]</span></p><p>于是：</p><p><span class="math display">\[\begin{equation}\begin{aligned}\widetilde{\left|n,g\right&gt;} =&amp; U \left|n,g\right&gt; = e^{-D}\left|n,g\right&gt;\\ =&amp; \sum_{m=0}^{infty} \frac{1}{(2m)!}(-1)^{2M}D^{2m}\left|n,g\right&gt;\\  +&amp;\sum_{m=0}^{infty} \frac{1}{(2m+1)!}(-1)D^{2m+1}\left|n,g\right&gt;\\ = &amp; \sum_{m=0}^{infty} \frac{1}{(2m)!}(-1)^{2M}(\frac{-\arctan (2\lambda \sqrt  n)}{2})^2m \left|n,g\right&gt; \\ +&amp; \sum_{m=0}^{infty} \frac{1}{(2m+1)!}(-1)^{m+1}(\frac{-\arctan (2\lambda \sqrt  n)}{2})^2m\left|n,g\right&gt;\\ =&amp; \cos (\Theta_n) \left|n,g\right&gt; - \sin (\Theta_n)\left|n-1,e\right&gt;\end{aligned}\end{equation}\]</span></p><p><span class="math inline">\(\Theta_n = \arctan{(2\lambda \sqrt{n})}/2\)</span>，同理：</p><p><span class="math display">\[\begin{equation}\begin{aligned}\widetilde{\left|n-1,e\right&gt;} = \sin (\Theta_n) \left|n,g\right&gt; + \cos (\Theta_n)\left|n-1,e\right&gt;\end{aligned}\end{equation}\]</span></p><p><a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.79.013819">推导来源与参考文献</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>量子计算,超导量子计算, supercoducting qubits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光场量子化及光的量子效应</title>
    <link href="/2023/06/30/quantum-optic1/"/>
    <url>/2023/06/30/quantum-optic1/</url>
    
    <content type="html"><![CDATA[<p>麦克斯韦方程组：</p><p><span class="math display">\[\begin{equation}\begin{aligned}\nabla\times\mathbf{H}&amp;={\frac{\partial\mathbf{D}}{\partial t}}\\\\\nabla\times\mathbf{E}&amp;=-{\frac{\partial\mathbf{B}}{\partial t}}\\\\\nabla\cdot\mathbf{B}&amp; = 0\\\\\nabla\cdot\mathbf{D}&amp;=0.\end{aligned}\end{equation}\]</span></p><h1 id="电磁场的量子化">电磁场的量子化</h1><p>一维空腔中的电场 $x $ 分量做傅里叶展开：</p><p><span class="math display">\[E_{x}(z,t)=\sum_{j}A_{j}q_{j}(t)\sin(k_{j}z)\]</span></p><p>其中<span class="math inline">\(k_{j} = j\pi/L, j =1,2,3..\)</span>，定义系数<span class="math inline">\(A_{j}=\left(\frac{2\nu_{j}^{2}m_{j}}{V\epsilon_{0}}\right)^{1/2}\)</span>，<span class="math inline">\(\nu_{j}=j\pi c/L\)</span>，由<span class="math inline">\(\nabla\times\mathbf{H}=\frac{\partial\mathbf{D}}{\partial t}\)</span>得到：</p><p><span class="math display">\[H_{y}=\sum_{j}A_{j}({\frac{\dot{q}_{j}\epsilon_{0}}{k_{j}}})\cos(k_{j}z)\]</span></p><p>The classical Hamiltonian for the field is</p><p><span class="math display">\[\begin{equation}\begin{aligned}\mathcal H&amp;=\frac{1}{2}\int_{V}d\tau(\epsilon_{0}E_{x}^{2}+\mu_{0}H_{y}^{2})\\&amp;=\frac{1}{2}\sum_{j}(m_{j}\nu_{j}^{2}q_{j}^{2}+m_{j}\dot{q}_{j}^{2})\\&amp;={\frac{1}{2}}\sum_{j}\left(m_{j}v_{j}^{2}q_{j}^{2}+{\frac{p_{j}^{2}}{m_{j}}}\right)\end{aligned}\end{equation}\]</span></p><p>其中升降算符满足：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;[a_j,a_{j&#39;}] = \delta_{jj&#39;} \\ &amp;[a_{j},a_{j^{\prime}}]=[a_{j}^{\dagger},a_{j^{\prime}}]=0\end{aligned}\end{equation}\]</span></p><p>则电场和磁场算符写为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;E_{x}(z,t)=\sum_{j}\mathscr{E}_{j}(a_{j}e^{-i\nu_{j}t}+a_{j}^{\dagger}e^{i\nu_{j}t})\sin k_{j}z\\&amp;H_{y}(z,t)=-i\epsilon_{0}c\sum_{j}\mathscr{E}_{j}(a_{j}e^{-i\nu_{j}t}-a_{j}^{\dagger}e^{i\nu_{j}t})\cos k_{j}z\end{aligned}\end{equation}\]</span></p><p>where the quantity <span class="math inline">\(\mathscr{E}_{j}=\left(\frac{\hbar\nu_{j}}{\epsilon_{0}V}\right)^{1/2}\)</span>，自由空间，<span class="math inline">\(k\)</span>可以任意，且可以视作是空腔的箱极限：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;E(r,t)= \sum_{k}{ \hat{\epsilon_{k}} \mathscr{E}_{k} \alpha_k e^{-i\nu_kt+i  k\cdot r} }+ c.c.\\&amp;H(r,t)=\frac{1}{\mu_0}\sum_{ k}\frac{ k\times\hat{\epsilon_{k}}}{v_{k}}\mathscr{E}_{k} {\alpha_{k}}e^{-i v_{k}t+i{k\cdot r}}+c.c.\end{aligned}\end{equation}\]</span></p><p>其中：<span class="math inline">\(\mathscr{E}_{k}=\left(\frac{\hbar\nu_{k}}{2\epsilon_{0}V}\right)^{1/2},k\cdot\hat{\epsilon}_{k}=0\)</span>，易得模密度的表达式：</p><p><span class="math display">\[D(\nu)d\nu=\frac{L^{3}\nu^{2}}{\pi^{2}c^{3}}d\nu,\]</span></p><p>电场与磁场的对易关系，将电场磁场写为：</p><p><span class="math display">\[E(r,t)=\sum_{ k,\lambda}\hat{\epsilon}_{ k}^(\lambda)E_k a_k,\lambda e^{-i\nu_kt+i k\cdot r}+H.c.,\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>quantum optics, quantum mechanics, quantization of photons</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>microwave2</title>
    <link href="/2023/04/18/microwave2/"/>
    <url>/2023/04/18/microwave2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内积空间的算符及谱分解定理</title>
    <link href="/2023/04/12/linear_algebra4/"/>
    <url>/2023/04/12/linear_algebra4/</url>
    
    <content type="html"><![CDATA[<h1 id="adjoint-map">adjoint map</h1><h2 id="定义">定义</h2><p>对于线性映射 <span class="math inline">\(T:V \rightarrow W\)</span> 定义： <span class="math inline">\(T^*:W \rightarrow V\)</span>，st :</p><p><span class="math display">\[\left&lt;Tv,w\right&gt; = \left&lt;v, T^* w\right&gt;\]</span></p><p>左边是 <span class="math inline">\(W\)</span> 空间的内积，右边是 <span class="math inline">\(V\)</span> 空间的内积。</p><p>首先写明 <span class="math inline">\(T^*\)</span> 是个映射：</p><p>当给定 <span class="math inline">\(T\)</span> 和 <span class="math inline">\(w\)</span> 之后，定义 <span class="math inline">\(V\)</span> 上的泛函，使得<span class="math inline">\(\varphi(v) = \left&lt;Tv,w\right&gt;\)</span>(显然可证是个泛函)，然后由 Riesz Representation Theorem可知，一定存在唯一的<span class="math inline">\(v&#39;\)</span>，st <span class="math inline">\(\varphi(v) = \left&lt;v,v&#39;\right&gt;\)</span>，于是自然定义<span class="math inline">\(T^* w = v&#39;\)</span>，由唯一性可知这是一个合法映射。</p><h2 id="性质">性质：</h2><p>简单易证<span class="math inline">\(T^*\)</span>是个线性映射，且具有以下性质</p><ol type="1"><li><span class="math inline">\((S+T)^* = S^*+T^*\)</span></li><li><span class="math inline">\((\lambda S)^* = \bar \lambda S^*\)</span></li><li><span class="math inline">\((T^{\*})^\* = T\)</span></li><li><span class="math inline">\((ST)^\* = T^\* S^\*\)</span></li></ol><p>映射空间性质：</p><p><span class="math display">\[range(T^*) = null(T)^{\bot}\\\\range(T) = null(T^*)^{\bot}\\\\null(T^*) = range(T)^{\bot}\\\\null(T) = range(T^*)^{\bot}\]</span></p><h1 id="自伴随算符self-adjoint-operators">自伴随算符(self-adjoint operators)</h1><h2 id="定义-1">定义</h2><p>Definition <mark>self-adjoint</mark> An operator <span class="math inline">\(T \in \mathcal{L}(V)\)</span> is called self-adjoint if <span class="math inline">\(T=T^*\)</span>. In other words <span class="math inline">\(T \in \mathcal{L}(V)\)</span> is self-adjoint if and only if <span class="math inline">\(\langle Tv,w\rangle\equiv\langle v,Tw\rangle\)</span> for all <span class="math inline">\(w\in V\)</span>.</p><h2 id="性质-1">性质</h2><p>7.13 Eigenvalues of self-adjoint operators are real.</p><p>7.15 Suppose <span class="math inline">\(V\)</span> is a complex inner product space and <span class="math inline">\(T\in\mathcal{L}(V\)</span> ). Then <span class="math inline">\(T\)</span> is self-adjoint if and only if <span class="math inline">\(\langle Tv,v\rangle\in\mathbb{R}\)</span> for every <span class="math inline">\(v \in V\)</span></p><p>hint: <span class="math inline">\(\langle T u,w\rangle=\frac{\langle T(u+w),u+w\rangle-\langle T(u-w),u-w\rangle}{4}+ \frac{ \langle T(u+i\,w),u+i\,w \rangle- \langle T(u-i\,w),u-i\,w \rangle}{4}i\)</span></p><p>(同时说明任意含<span class="math inline">\(T\)</span>映射内积<span class="math inline">\(\langle Tv,w\rangle\)</span>可以被 <span class="math inline">\(\langle Tu,u\rangle\)</span> 这种形式改写)</p><h1 id="normal-算符">Normal 算符</h1><h2 id="定义-2">定义</h2><p>Definition <mark>normal</mark> An operator on an inner product space is called normal if it commutes with its adjoint In other words, <span class="math inline">\(T\in\mathcal{L}(V)\)</span> is normal if <span class="math inline">\(TT^{\*}=T^{\*}T\)</span>.</p><h2 id="性质-2">性质</h2><p>7.20 <span class="math inline">\({T}\)</span> is normal if and only if <span class="math inline">\(||Tv|| = ||T^ * v||\)</span> for all <span class="math inline">\(v \in V\)</span> （这也就说明 <span class="math inline">\(T\)</span> 和 <span class="math inline">\(T^*\)</span> 的null空间相同)。</p><p>7.21 For <span class="math inline">\(T\)</span> normal and <span class="math inline">\(T\)</span> has a eigenvector with eigenvalue <span class="math inline">\(\lambda\)</span>. Then <span class="math inline">\(v\)</span> is also an eigenvector of <span class="math inline">\(T^*\)</span> with eigenvalue <span class="math inline">\(\bar\lambda\)</span>.</p><p>(hint: <span class="math inline">\(T-\lambda I\)</span> 也是 normal 的，借助此证明）</p><p>7.22 Suppose <span class="math inline">\(T\in\mathcal{L}(V)\)</span> is normal. Then eigenvectors of <span class="math inline">\(T\)</span> corresponding to distinct eigenvalues are orthogonal.</p><p>hint: <span class="math inline">\((\lambda_1-\lambda_2)\left&lt;v_1|v_2\right&gt;\)</span></p><h1 id="complex-spectral-theorem">Complex Spectral Theorem</h1><p>Suppose <span class="math inline">\(F=C\)</span> and <span class="math inline">\(T∈ \mathcal{L}(V)\)</span>. Then the following are equivalent:</p><ol type="a"><li><span class="math inline">\(T\)</span> is normal.</li><li><span class="math inline">\(V\)</span> has an orthonormal basis consisting of eigenvectors of <span class="math inline">\(T\)</span>.</li><li><span class="math inline">\(T\)</span> has a diagonal matrix with respect to some orthonormal basis of <span class="math inline">\(V\)</span>.</li></ol><p>(hint: Schur’s Theorem: Suppose <span class="math inline">\(V\)</span> is a finite-dimensional complex vector space and <span class="math inline">\(T\)</span> is linear operator Then has an upper-triangular matrix with respect to some orthonormal basis of V)</p><h1 id="real-spectral-theorem">Real Spectral Theorem</h1><p>(证明略复杂，见书，不想掌握)</p><p>Suppose <span class="math inline">\(\mathcal F\)</span> is <span class="math inline">\(R\)</span> and <span class="math inline">\(T \in \mathcal L(V)\)</span>. Then the following are equivalent:</p><ol type="a"><li><span class="math inline">\(T\)</span> is self-adjoint.</li><li><span class="math inline">\(V\)</span> has an orthonormal basis consisting of eigenvectors of <span class="math inline">\(T\)</span>.</li><li><span class="math inline">\(T\)</span> has a diagonal matrix with respect to some orthonormal basis of <span class="math inline">\(V\)</span>.</li></ol><h1 id="半正定算符">半正定算符</h1><h2 id="definition">Definition</h2><p><mark>positive operator</mark> : An operator <span class="math inline">\(T\in \lambda(V)\)</span> is called positive if <span class="math inline">\({T}\)</span> is self-adjoint and $ Tv,v $ for all <span class="math inline">\(v\in V\)</span>.</p><p>An operator <span class="math inline">\(R\)</span> is called a <mark>square root</mark> of an operator T if <span class="math inline">\(R^2 = T\)</span>.</p><h2 id="性质-3">性质</h2><p>7.35 Let <span class="math inline">\(T \in \mathcal L (V)\)</span>. Then the following are equivalent: (a) T is positive; (b) T is self-adjoint and all the eigenvalues of T are nonnegative; (c) T has a positive square root; (d) T has a self-adjoint square root; (e) there exists an operator <span class="math inline">\(R \in \mathcal L (V)\)</span> such that <span class="math inline">\(T =R^*R\)</span>.</p><p>7.36 Every positive operator on <span class="math inline">\(V\)</span> has a unique positive square root.</p><h1 id="isometry-operator">isometry operator</h1><h2 id="定义-3">定义</h2><p>An operator <span class="math inline">\(S\in\mathcal{L}(V)\)</span> is called an <mark>isometry</mark> if <span class="math inline">\(\|S\nu\|=\|\nu\|\)</span> for all <span class="math inline">\(v ∈ V\)</span>. In other words, an operator is an isometry if it preserves norms.</p><h2 id="性质-4">性质</h2><p>7.42 Suppose <span class="math inline">\(S ∈ \mathcal{L}(V)\)</span>. Then the following are equivalent:</p><ol type="a"><li><span class="math inline">\(S\)</span> is an isometry.</li><li>$&lt;Su,Sv&gt; =&lt;u,v&gt; $ for all <span class="math inline">\(u,v \in V\)</span>.</li><li><span class="math inline">\(Se_1,...,Se_n\)</span> is orthonormal for every orthonormal list of vectors <span class="math inline">\(e_1,...,e_n\)</span> in <span class="math inline">\(V\)</span>.</li><li>there exists an orthonormal basis <span class="math inline">\(e_1,...,e_n\)</span> of <span class="math inline">\(V\)</span> such that <span class="math inline">\(S e_1,\ldots,S e_n\)</span> is orthonormal.</li><li><span class="math inline">\(S^\*S = 1\)</span>.</li><li><span class="math inline">\(SS^\*=1\)</span>.</li><li><span class="math inline">\(S^\*\)</span> is an isometry.</li><li><span class="math inline">\(S\)</span> is invertible and <span class="math inline">\(S^{-1}=S\)</span>.</li></ol><p>7.43 Suppose <span class="math inline">\(V\)</span> is a complex inner product space and <span class="math inline">\(S∈ \mathcal{L}(V)\)</span>. Then the following are equivalent:</p><ol type="a"><li><span class="math inline">\(S\)</span> is an isometry.</li><li>There is an orthonormal basis of <span class="math inline">\(V\)</span> consisting of eigenvectors of <span class="math inline">\(S\)</span> whose corresponding eigenvalues all have absolute value 1.</li></ol><p>（hint: 谱分解定理）</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数, linear algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测量理论1</title>
    <link href="/2023/03/27/measurement1/"/>
    <url>/2023/03/27/measurement1/</url>
    
    <content type="html"><![CDATA[<h1 id="经典测量理论">经典测量理论</h1><p>一个物理学量用 <span class="math inline">\(x\)</span> 表示（可以是离散的，也可以是连续的，一维或者多维都行），在测量前并不知道其具体的取值，但是知道其取值范围，并且由于经验或者别的信息，知道他在每个取值上的概率分布 <span class="math inline">\(P(x)\)</span>（先验概率分布 或者 state-of-knowledge）。</p><p>假设似然函数（likelihood function）已知，其定义为：<span class="math inline">\(P(y|x)\)</span>，在 <span class="math inline">\(x\)</span> 给定的条件下，<span class="math inline">\(y\)</span> 被测得的概率。</p><p>在单次测量中，我们得到一次测量结果<span class="math inline">\(y_0\)</span>，根据测量结果对我们的 state-of-knowledge 进行更新，这个过程叫做完成了一次测量。</p><p>由贝叶斯定理：</p><p><span class="math display">\[\begin{equation}\begin{aligned}P(x|y_0) = \frac{P(xy_0)}{P(y_0)} = \frac{P(y_0|x)P(x)}{\sum_x P(y_0|x)P(x)}\end{aligned}\end{equation}\]</span></p><p>等式右边 <span class="math inline">\(P(x)\)</span> 代表测量前我们对参量 <span class="math inline">\(x\)</span> 的知识（state-of-knowledge），<span class="math inline">\(P(y_0|x)\)</span>则是似然函数，测量发生后，根据测量结果我们将知识更新为 <span class="math inline">\(P(x|y_0)\)</span>。</p><p>任意 <span class="math inline">\(N\)</span> 次测量，彼此之间都是无关，<span class="math inline">\(x\)</span> 的概率分布可以写为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}P(x|y_1,y_2,..y_N) &amp;= \frac{P(y_N|x,y_1,y_2,...y_{N-1})P(x|y_1,y_2,...y_{N-1})}{\mathcal{N_{y_i}}}\\\\ &amp;=  \frac{P(y_N|x,...)P(y_{N-1}|x,...)...P(y_{1}|x)P(x)}{\Pi_i \mathcal{N}_i }\end{aligned}\end{equation}\]</span></p><p>其中</p><div><span class="math inline">\(\mathcal{N}_{i} = \sum_x P(y_i|x,...)P(x|y_1,y_2,...y_{i-1})\)</span></div><p>原式化简为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}P(x|y_1,y_2,..y_N) &amp;= \Pi_i \frac{P(y_i|x,y_1,y_2,...y_{i-1})}{\sum_x P(y_i|x,y_1,y_2,...y_{i-1})P(x|y_1,y_2,...y_{i-1})}\\\\ &amp; = \Pi_i \frac{P(y_i|x)}{\sum_x P(y_i|x)P(x|y_1,y_2,...y_{i-1})} P(x)\end{aligned}\end{equation}\]</span></p><p>其中，变量相互之间无关，意味着每次测量后似然关系没有改变既<span class="math inline">\(P(y_i|x,y_1,y_2,...y_{i-1}) = P(y_i|x)\)</span>，也就是测量并没有改变物理量的大小(当然我觉得弱关联近似成立也是有可能的)。</p><p>实际上下方的归一化系数不太重要，重要的是分母上方的乘积，可以直接相乘之后再做归一化。</p><p>在实际测量中，往往由于测量误差是由多个相互独立的随机变量造成的影响，所以 <span class="math inline">\(P(y|x)\)</span> 似然函数往往为gauss型函数。同样，在经过多次测量后，任意给定一个物理量的取值<span class="math inline">\(x_0\)</span>，想求该物理量取值为<span class="math inline">\(x_0\)</span>的概率可以写为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}P(x_0|y_1,y_2,..y_N) &amp;= P(y_1|x_0)P(y_2|x_0)P(y_3|x_0)... P(x_0)/N\\\\ &amp;= \mathscr{F}^{-1}(\tilde P(w_1) * \tilde P(w_2)... \tilde P(w_N)) P(x_0)/N\end{aligned}\end{equation}\]</span></p><p>其中 <span class="math inline">\(\tilde P(w)\)</span> 为概率 <span class="math inline">\(P(y|x_0)\)</span> 关于 <span class="math inline">\(y\)</span> 的傅里叶变换，内部代表对其卷积，<mark>假设 <span class="math inline">\(\tilde P(w)\)</span> 为方差有限且在无穷上可积的函数</mark>，则可以将其归一化后看作是 <span class="math inline">\(w\)</span> 上的一个概率分布，再根据</p><p><span class="math display">\[\begin{equation}\begin{aligned}P(x+y) = P(x) *P(y)\end{aligned}\end{equation}\]</span></p><p>可知，$P(x_0|y_1,y_2,..y_N) = ^{-1}(CP(w_1+w_2+w_3...w_n)) <span class="math inline">\(，再由中心极限定理可知，\)</span>CP(w_1+w_2+w_3...w_n)$ 满足gauss分布，所以其傅里叶变换也是gauss分布。</p><p>在绝大多数情况下，对物理量的初始知识并不重要，不会影响到最终结果，但不是绝对的，为了避免 prior states-of-knowledge 对测量产生影响，需要选定特殊的先验知识来表达对物理量 “一无所知”，同时得考虑到测量的鲁棒性，也就是一些outliers不能对测量结果产生巨大的影响，得选用一些特殊的先验知识，具体的参看<a href="https://www.cambridge.org/cn/academic/subjects/physics/theoretical-physics-and-mathematical-physics/probability-theory-logic-science?format=HB&amp;isbn=9780521592710">书 part2 chapter21</a></p><h1 id="一次经典的长度测量">一次经典的长度测量</h1><p>对一把长度为20的尺子进行测量，对恒为正数且完全无知的测量值prior知识的写法最好写为 <span class="math inline">\(p(x) = a/x\)</span>，其中 <span class="math inline">\(a\)</span> 为某个任意常数，由于肉眼和仪器导致误差呈现高斯分布，假设其<span class="math inline">\(\sigma = 0.5\)</span>，对应的like-hood关系也是高斯的 <span class="math inline">\(\sigma = 0.5\)</span> 的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib.animation <span class="hljs-keyword">import</span> FuncAnimation<br><br>fig,ax = plt.subplots(figsize=(<span class="hljs-number">1</span>*<span class="hljs-number">12</span>,<span class="hljs-number">1</span>*<span class="hljs-number">9</span>),facecolor=<span class="hljs-string">&#x27;white&#x27;</span>,edgecolor=<span class="hljs-string">&#x27;white&#x27;</span>)<br><br><span class="hljs-comment"># 测量的参数</span><br>N = <span class="hljs-number">300</span> <span class="hljs-comment">#测量的次数</span><br>sigma = <span class="hljs-number">0.5</span> <span class="hljs-comment">#like-hood 呈高斯型，其方差</span><br>x0 = <span class="hljs-number">20</span> <span class="hljs-comment">#尺子的长度</span><br>errors = np.random.normal(mu, sigma, N)<br>measures  = x0+errors <span class="hljs-comment">#测量结果</span><br><br><span class="hljs-comment">#作图</span><br><br>x = np.linspace(<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">20000</span>)<br>state_of_knowledge = [<span class="hljs-number">100</span>/i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x] <span class="hljs-comment">#图像上只呈现19-21的变化</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>    <span class="hljs-keyword">global</span> state_of_knowledge<br>    state_of_knowledge = state_of_knowledge/<span class="hljs-built_in">sum</span>(state_of_knowledge)<br>    ax.axvline(x0, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, color=<span class="hljs-string">&#x27;black&#x27;</span>)<br>    line, = ax.plot(x,state_of_knowledge)<br>    <span class="hljs-keyword">return</span> line<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">measurement_value</span>): <span class="hljs-comment">#一个frame代表一次测量</span><br>    <span class="hljs-keyword">global</span> state_of_knowledge<br>    ax.clear()<br>    ax.axvline(x0, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, color=<span class="hljs-string">&#x27;black&#x27;</span>)<br>    state_of_knowledge = [state_of_knowledge[i]*np.exp(-(x[i]-<span class="hljs-number">20</span>)**<span class="hljs-number">2</span>/<span class="hljs-number">2</span>/sigma**<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20000</span>)]<br>    state_of_knowledge = state_of_knowledge/<span class="hljs-built_in">sum</span>(state_of_knowledge)<br>    line, = ax.plot(x,state_of_knowledge)<br>    <span class="hljs-keyword">return</span> line<br><br>anim = FuncAnimation(fig,update,frames=measures,interval=<span class="hljs-number">30</span>,init_func = init) <span class="hljs-comment">#每一秒完成30次测量</span><br>anim.save(<span class="hljs-string">&quot;measure.gif&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="measure.gif" width="80%"></p>]]></content>
    
    
    <categories>
      
      <category>量子测量</category>
      
    </categories>
    
    
    <tags>
      
      <tag>量子力学, quantum mechanics, quantum measurement</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波电路基本概念</title>
    <link href="/2023/03/19/microwave1/"/>
    <url>/2023/03/19/microwave1/</url>
    
    <content type="html"><![CDATA[<h1 id="微波的定义">微波的定义</h1><p><img src="1.png" width="70%"></p><p>频段在 <span class="math inline">\(30Hz-300GHz\)</span> 之间的电磁波被称为微波，由电动力学中，导体的透射深度 <span class="math inline">\(\Delta = \sqrt{\frac{2}{w\mu\sigma}}\)</span> 可知，电磁波在微波频段的透射深度在 <span class="math inline">\(10^{-6}m\)</span> 左右，于是采用传输线来传播电磁波，与经典电路不同，微波导线不具有对应的“电信号”。</p><p>采用化场为路的思想，也方便将经典电路中的处理方法过渡到微波电路中，可以将传输线理论运用到微波电路中，其电流和电压可以与电磁波的电场和磁场的场分量作一个对应，其具体对应关系：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;u \equiv E_x, i \equiv H_y\\\\ &amp;L \equiv \mu, C \equiv \epsilon\end{aligned}\end{equation}\]</span></p><p>将解空气中的麦克斯韦方程组改写为解微波电路中“电压”和“电流”的分布问题，于是单色电磁波的传播方程与电报方程相互等价：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;\frac{\partial^2 E_x}{\partial z^2} + w^2/C_{lignt} E_x = 0 \\\\&amp; \frac{\partial^2 u}{\partial z^2} + w^2LC u = 0 \end{aligned}\end{equation}\]</span></p><p>而<span class="math inline">\(Z_0 = \frac{L}{C}\)</span> 类似于平面波中的波阻，用于描述电场与磁场的比例关系。</p><p><img src="4.png" width="100%"></p><h1 id="传输线理论原理">传输线理论原理</h1><p>能够用传统直流电路或者低频交流电路的处理方法直接解决的电路称为集总电路，其中电信号的波动所对应的电磁波波长远远大于其电路尺寸，而当输入低频交流讯号，但传输距离很远时，其上的电压电流由于导线和大地的电容，导线的电感和电阻呈现波动，其信号传播满足电报员方程，这种电路被称为分布电路。</p><p><img src="5.png" width=" %"></p><p>如图所示，其为传输线的一般结构，对应于微波电路</p><p><img src="6.jpg" width="75%"></p><p>建立两套坐标系，<span class="math inline">\(z=l-z&#39;\)</span>，通过解方程可知，波的传播一般解对应：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;u(z) = A_1 e^{-j\beta z} +A_2 e^{j\beta z}\\\\&amp;i(z) = \frac{1}{Z_0} (A_1 e^{-j\beta z} - A_2 e^{j\beta z} )\end{aligned}\end{equation}\]</span></p><p><span class="math inline">\(\beta = w\sqrt{LC}\)</span>，项1对应正向传播的波，而项2对应负向传播的波，通过限定其输入的<span class="math inline">\(U_0,I_0\)</span> 可以解出系数从而解出波其上的<span class="math inline">\(u,i\)</span>分布，或者给出输出条件 <span class="math inline">\(U_l,I_l\)</span> 也可以得到电流电压分布，此时使用<span class="math inline">\(z&#39;\)</span> 坐标系更为方便。</p><p>假设负载处的电压为 <span class="math inline">\(U_l\)</span>, 电流为 <span class="math inline">\(I_l\)</span>，通过解方程得到系数，传输线上的电压写为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}u(z&#39;) &amp;= U_l \cos(\beta z&#39;) + j I_lZ_0\sin(\beta z&#39;)\\\\ &amp;= \frac{(U_l+Z_0I_l)}{2} e^{j\beta z&#39;}  + \frac{(U_l-Z_0I_l)}{2} e^{-j\beta z&#39;} \\\\ i(z&#39;) &amp;= \frac{ju(l)}{Z_0} \cos(\beta z&#39;)+ i(l)\sin(\beta z&#39;)\\\\ &amp;= \frac{(U_l+Z_0I_l)}{2Z_0} e^{j\beta z&#39;}  -\frac{(U_l-Z_0I_l)}{2Z_0} e^{-j\beta z&#39;} \end{aligned}\end{equation}\]</span></p><p>定义某点处的反射系数 <span class="math inline">\(\Gamma= \frac{u-Z_0i}{u+Z_0i}\)</span>，其模长代表某点处两个方向的波的电压振幅比值，俯角代表相位差，定义阻抗 <span class="math inline">\(Z = u/i\)</span>。</p><p>根据通解，容易得到，在 <span class="math inline">\(z&#39;\)</span> 处的反射系数和阻抗有：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;\Gamma(z&#39;) = \Gamma_l e^{-2j\beta z&#39;}\\\\&amp;Z(z&#39;) = Z_l \frac{1+\Gamma(z&#39;)}{1-\Gamma(z&#39;)} \end{aligned}\end{equation}\]</span></p><h1 id="传输线状态分析">传输线状态分析</h1><h2 id="行波和全驻波状态">行波和全驻波状态</h2><p>当<span class="math inline">\(Z_l = Z_0\)</span> 时， <span class="math inline">\(\Gamma_l=0\)</span>，通过变量代换$z = l- z' $，容易将波表达式写为：</p><p><span class="math display">\[\begin{equation}\begin{aligned}u(z) &amp;= \frac{U_l+Z_0I_l}{2}e^{j\beta l} e^{-j\beta z} + \frac{U_l-Z_0I_l}{2}e^{-j\beta l} e^{j\beta z} \\\\ &amp;= \frac{U_l+Z_0I_l}{2}e^{j\beta l} e^{-j\beta z} =   \frac{U_0+Z_0I_0}{2} e^{- i\beta z}\end{aligned}\end{equation}\]</span></p><p><span class="math inline">\(U_0,I_0\)</span>为波源处的电压电流，只存在从波源向负载输入方向的波，从而波源处向内发出任意单色波，都不会被反射，这种情况被称为行波状态。</p><p>容易证得当负载为纯电抗时，既<mark> <span class="math inline">\(Z_l = jX_l\)</span> 时与电路中的<span class="math inline">\(|\Gamma(z&#39;)| = |\Gamma_l| = 1\)</span>等价</mark>，所以可以把反射系数写为<span class="math inline">\(\Gamma_l = e^{i\varphi_l}\)</span></p><p>任意处的阻抗：</p><p><span class="math display">\[\begin{equation}\begin{aligned}Z(z&#39;) &amp;= \frac{Z_l+jZ_0\tan(\beta z&#39;)}{Z_0+jZ_l\tan(\beta z&#39;)}  \\\\ &amp;= jZ_0\frac{X_l/Z_0 +\tan(\beta z&#39;)}{1 -X_l/Z_0 \tan(\beta z&#39;)}   \\\\ &amp; = jZ_0 \tan(\beta (z+\Delta z))\end{aligned}\end{equation}\]</span></p><p>其中 <span class="math inline">\(\Delta z = \arctan(\frac{X_l}{Z_0})\)</span>，当<span class="math inline">\(X_l = 0\)</span> 既短路时：</p><p><span class="math display">\[\begin{equation}\begin{aligned}Z(z&#39;) &amp;=jZ_0 \tan(\beta z&#39;) \\\\&amp;= Z_0 \frac{1-e^{-j2\beta z&#39;}}{1 + e^{-j2\beta z&#39;}}\end{aligned}\end{equation}\]</span></p><p>将其视作 “标准状态”，再由：</p><p><span class="math display">\[\begin{equation}\begin{aligned}Z(z&#39;)&amp; = Z_0 \frac{1+\Gamma_le^{-j2\beta z&#39;}}{1- \Gamma_le^{-j2\beta z&#39;}}\\\\   &amp; = Z_0 \frac{1-e^{-j(2\beta z&#39;+ \pi - \varphi_l)}}{1 + e^{-j(2\beta z&#39;+ \pi - \varphi_l)}}\end{aligned}\end{equation}\]</span></p><p>得到 <span class="math inline">\(\Delta z\)</span> 与 <span class="math inline">\(\varphi_l\)</span> 的关系：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;\varphi_l = \pi  - 2arctan(X_l/Z_0)\\\\&amp;\Delta_z = \lambda_g \arctan(X_l/Z_0)/2\pi\\\\&amp;\varphi_l +\frac{4\pi \Delta Z}{\lambda_g} = \pi\end{aligned}\end{equation}\]</span></p><p>其中<span class="math inline">\(\lambda_g = 2\pi/\beta\)</span>，</p><p><span class="math display">\[\begin{equation}\begin{aligned}u(z) = U_l e^{j\beta z&#39;} + \Gamma_l U_l e^{-j\beta z&#39;}\\\\ =   U_l e^{j\beta z&#39;} +U_l e^{-j\beta z&#39;+j\varphi_l}\\\\ =   U_le^{j\phi_l/2}(e^{j\beta z&#39;&#39;} +e^{-j\beta z&#39;&#39;})\end{aligned}\end{equation}\]</span></p><p>其中<span class="math inline">\(z&#39;&#39; = -\frac{\varphi_l}{2\beta}+z&#39;\)</span>，相当于当负载为纯电抗时，波在负载处会被完全反射并且有一个相差，其能够与入射波干涉产生有相较于短路的标准状态 <span class="math inline">\(\Delta z\)</span> 位移的驻波。</p><h2 id="行驻波">行驻波</h2><p>最一般的情况，当<span class="math inline">\(\Gamma_l = |\Gamma_l|e^{i\varphi_l},Z_l = R_l +iX_l\)</span>时：</p><p><span class="math display">\[\begin{equation}\begin{aligned}u(z&#39;)&amp; = U_l^+(e^{j\beta z&#39;} +\Gamma_l e^{-j\beta z&#39;})\\\\ &amp;= U_l^+(1-|\Gamma_l|)e^{j\beta z&#39;} +2jU_l^+|\Gamma_l| e^{j(\varphi_l-\pi)/2}\sin[\beta(z&#39;-\frac{1}{2\beta(\varphi_l-\pi)})]\end{aligned}\end{equation}\]</span></p><p>分为了两部分，第一部分是部分射入的行波，第二部分是反射波与行波相互交叠发生的干涉驻波。由反射系数与阻抗的关系：</p><p><span class="math display">\[\begin{equation}\begin{aligned}Z(z&#39;) &amp;= Z_0 \frac{1+ \Gamma(z)}{1- \Gamma(z)}\\\\ &amp;= Z_0 \frac{\rho+j\tan(\beta z&#39; - \varphi_l/2)}{1+j\rho\tan(\beta z&#39; - \varphi_l/2)}\end{aligned}\end{equation}\]</span></p><p>其中<span class="math inline">\(\rho = \frac{1+ \Gamma_l}{1- \Gamma_l}\)</span>(电压驻波比)，根据<span class="math inline">\(u(z&#39;) = U_l^+(e^{j\beta z&#39;} +\Gamma_l e^{-j\beta z&#39;})\)</span> 以及定义，其物理含义为电压振幅的最大值和最小值的比值。</p><p>已知 <span class="math inline">\(\Gamma_l = \frac{Z_l -Z_0}{Z_l+Z_0} = \frac{R_L -Z_0+jX_l}{R_L +Z_0+jX_l}\)</span>，由复数除法的几何意义可知反射系数的俯角：</p><p><span class="math display">\[\begin{equation}\begin{aligned}\varphi_l = \pi - \arctan(\frac{X_l}{Z_0+R_l})+ [\arctan(\frac{X_l}{Z_0-R_l})]\end{aligned}\end{equation}\]</span></p><p>同样的，需要选定 “标准状态” 来定义 <span class="math inline">\(\Delta z\)</span>，当<span class="math inline">\(Z_L = R_L&lt;Z_0\)</span> 时，<span class="math inline">\(\varphi_l = 0\)</span> 选用其为标准状态，则定义 <span class="math inline">\(\Delta z = (\pi - \varphi_l)/2\beta\)</span>，任意负载的电压和阻抗：</p><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;u(z&#39;) = U_l^+(1-|\Gamma_l|)e^{j\beta z&#39;} +2jU_l^+|\Gamma_l| e^{j(\varphi_l-\pi)/2}\sin[\beta(z&#39;+\Delta z)]\\\\ &amp;Z(z&#39;) = \frac{1+j\rho \tan(\beta(z&#39;+\Delta z))}{\rho+j \tan(\beta(z&#39;+\Delta z))}\end{aligned}\end{equation}\]</span></p><p>标准状态的电压电流如图所示：</p><p><img src="6.png" width="70%"></p><p>而更一般的情况如图所示：</p><p><img src="7.png" width="100%"></p><p><span class="math inline">\(d_{min}\)</span>代表波节和终端处的最小距离</p>]]></content>
    
    
    <categories>
      
      <category>微波电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微波电路设计, Microwave Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二次量子化和场算符</title>
    <link href="/2023/02/25/quantum6/"/>
    <url>/2023/02/25/quantum6/</url>
    
    <content type="html"><![CDATA[<h1 id="一次量子化下的多体波函数表示">一次量子化下的多体波函数表示</h1><p>假设在某个空间中，存在N个粒子，则整个系统的哈密顿量写为:</p><p><span class="math display">\[\hat{H} = \sum_{i=1}^N T(x_i) +\frac{1}{2} \sum_{k\ne l=1}^{N} V(x_k,x_l) \]</span></p><p>其中<span class="math inline">\(x_i\)</span>是用于表征第<span class="math inline">\(i\)</span>粒子的状态所用的坐标，它可以是实空间的坐标，也可以是自旋等离散的坐标，也可以是两者的组合等等。</p><p>假设每个粒子都存在完全力学量集<span class="math inline">\(\{E_k\}\)</span>，表示第k个单体的本征能级<span class="math inline">\({\epsilon_{E_k = eigen-state1},\epsilon_{E_k = eigen-state2}...\}\)</span>和本征态<span class="math inline">\({\psi_{E_k=eigen-state1}(x_k),\psi_{E_k = eigen-state2}(x_k)...\}\)</span>，则此系统所对应的波函数：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    \psi(x_1,x_2,...x_n,t)= \sum_{E_1,E_2,E_3,...E_N} C(E_1,E_2,...E_N,t) \psi_{E_1}(x_1) \psi_{E_2}(x_2)...\psi_{E_N}(x_n)    \end{aligned}\end{equation}\]</span></p><p>求和号表示，对所有可能的本征态组合求和。</p><h1 id="薛定谔方程">薛定谔方程</h1><p>对于任意的波函数，想求其分量<span class="math inline">\(C(E_1,E_2,...E_N,t)\)</span>，可以用<span class="math inline">\(\left&lt;\psi_{E_1}(x_1) \psi_{E_2}(x_2)...\psi_{E_N}(x_n) |\psi\right&gt;\)</span>的方法来求，求其随时演化的可以将<span class="math inline">\(\left|\psi \right&gt;\)</span> 带入薛定谔方程并且左积<span class="math inline">\(\left&lt;\psi_{E_1}(x_1) \psi_{E_2}(x_2)...\psi_{E_N}(x_n) \right|\)</span>化简得到：</p><p><span id="eq1"> <span class="math display">\[\begin{equation}    \begin{aligned}    &amp;i\hbar \frac{\partial C(E_1,E_2,...E_N,t)}{\partial t}    \\\\ =&amp; \sum_k \sum_{W} C(E_1,E_2,...W,E_{k+1},..E_N,t)\left&lt;\psi_{E_k}| T(x_k) |\psi_{W} \right&gt;    \\\\ &amp;+ \sum_i \sum_j \sum_{W}\sum_{M} C(E_1,E_2,...M,E_{j+1},...W,E_{i+1},..E_N,t)\left&lt;\psi_{E_i}\psi_{E_j}| V(x_i,x_j) |\psi_{W}\psi_{M} \right&gt;    \end{aligned}\end{equation}\]</span> </span></p><p>其中<span class="math inline">\(k,i,j\)</span>的取值从1到粒子总数N，而<span class="math inline">\(W,M\)</span>的含义是当<span class="math inline">\(k,i,j\)</span>取定后<span class="math inline">\(E_k,E_i,E_j\)</span>所对应的所有单体本征值和本征态。</p><h2 id="玻色子">玻色子</h2><p>假设共有<span class="math inline">\(M\)</span>个粒子，假设有<span class="math inline">\(N\)</span>个全同玻色子，为了便于分析，将同一种玻色子的编号编在前N位，其余的不同种的粒子放在后边。即，</p><p><span class="math display">\[\psi(x_1,x_2,..x_N,x_{N+1},...x_{M},t)\]</span></p><p><span class="math inline">\(x_1\)</span>到<span class="math inline">\(x_n\)</span>对应同种玻色子，后面为了方便，简写其后的<span class="math inline">\(x_{N+i}\)</span>，记为<span class="math inline">\(\psi(x_1,x_2,..x_N,t)\)</span>，由量子力学基本假设有：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    \psi(x_1,x_2,.x_i,...x_j..x_N,t) = \psi(x_1,x_2,..,x_j,...x_i...x_N,t)    \end{aligned}\end{equation}\]</span></p><p>将波函数对应上方的展开方法展开之后，容易得到：</p><p><span class="math inline">\(\forall \{E_1,E_2,...E_N\}, C(E_1,...E_i,..E_j,..E_N,t) =C(E_1,...E_j,..E_i,..E_N,t)\)</span>与上式条件完全等价。</p><p>这里评价一下，因为<span class="math inline">\(1\)</span>到<span class="math inline">\(N\)</span>都是全同粒子，所以完全可以用同一套本征态来进行展开，而等式的含义，举个例子，假设该种玻色子的本征态<span class="math inline">\(E\)</span>可以取<span class="math inline">\(0,1,2,3,..\)</span>，波函数在第i个粒子在5态，第j个粒子在4态的某个态上的分量，与波函数在第i个粒子在4态，第j个粒子在5态的，其余粒子取态都相同的态的分量相同，其余的参数完全相同。</p><p>对展开系数进行变量代换，设<span class="math inline">\(n_i\)</span>指第i个单体本征态上的粒子个数，则定义:</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    \bar C(n_1,n_2,...n_\infty,t) \equiv C(E_1,...E_i,..E_j,..E_N,t)    \end{aligned}\end{equation}\]</span></p><p>其中变量$ \{E_1,E_2,...E_3\} <span class="math inline">\(满足有\)</span>n_1<span class="math inline">\(个取值等于第一个单体本征值\)</span><em>{eigen-state1}<span class="math inline">\(，\)</span>n_2<span class="math inline">\(个取\)</span></em>{eigen-state_1}<span class="math inline">\(，由前文的交换对称性可知，这个定义是well-defined的，交换任意的\)</span>E_i,E_j<span class="math inline">\(所对应的\)</span>C'<span class="math inline">\(都等于\)</span>C$。</p><p>再定义:</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    f(n_1,n_2,...n_\infty,t) &amp;= (\frac{N!}{n_1!n_2!..n_\infty!})^{1/2}\bar C(n_1,n_2,...n_\infty,t)     \\\\ \varphi_{n_1,n_2,...n_\infty}(x_1,x_2,...x_n) &amp;= (\frac{n_1!n_2!..n_\infty!}{N!})^{1/2}\sum_{E_1,E_2,...E_N} \psi_{E_1}(x_1) \psi_{E_2}(x_2)...\psi_{E_N}(x_n)    \end{aligned}\end{equation}\]</span></p><p>其中，第二行的求和号表示对所有满足<span class="math inline">\(n_1,n_2,...n_\infty\)</span>的<span class="math inline">\(E_1,E_2...E_N\)</span>进行求和。</p><p>容易验证：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    \psi(x_1,x_2,...x_N,t) = \sum_{n_1,n_2,n_3,...n_\infty} f(n_1,n_2,...n_\infty,t)\varphi_{n_1,n_2,...n_\infty}(x_1,x_2,...x_N)    \end{aligned}\end{equation}\]</span></p><p>其中<span class="math inline">\(\sum_i n_i = N\)</span>，<span class="math inline">\(\left&lt;\varphi_{n_1,n_2,...n_\infty}|\varphi_{n_1,n_2,...n_\infty}\right&gt; =1\)</span>且<span class="math inline">\(\left|\varphi_{n_1,n_2,...n_\infty}\right&gt;(x_1,x_2,...x_N)\)</span>是一个满足交换对称性的波函数。</p><p>回到<a href="#eq1">薛定谔方程</a>，作为例子，对等号右边动能项进行改写，</p><p><span class="math display">\[\begin{equation}    \begin{aligned}     \sum_k \sum_{W} C(E_1,E_2,...W,E_{k+1},..E_N,t)\left&lt;\psi_{E_k}| T(x_k) |\psi_{W} \right&gt;     \end{aligned}\end{equation}\]</span></p><p>给定<span class="math inline">\(\\{E_1,E_2,...E_N\\}\)</span>之后，得到对应的<span class="math inline">\(\\{n_1,n_2,..n_\infty\\}\)</span>，则可以将<span class="math inline">\(C\)</span>用$C $改写：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    \sum_k \sum_{W} \bar C(n_1,n_2,.,n_{E_K}-1,..n_{W}+1,..n_\infty,t)\left&lt;\psi_{E_k}| T(x_k) |\psi_{W} \right&gt;     \end{aligned}\end{equation}\]</span></p><p>在对所有粒子求和<span class="math inline">\(\sum_{k=1}^{N}\)</span>的过程中，通过表达式可以看出，如果<span class="math inline">\(E_{k_1} = E_{k_2}\)</span>则<span class="math inline">\(k_1\)</span>号粒子和<span class="math inline">\(k_2\)</span>号粒子的 求和项表达式$<em>{W} C(n_1,n_2,.,n</em>{E_K}-1,..n_{W}+1,..n_,t)&lt;<em>{E_k}| T(x_k) |</em>{W} &gt; $完全一样，将所在能级一致的粒子放在一起求和，所以再次改写：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    &amp;\sum_i^{\infty} \sum_{W} n_i \bar C(n_1,n_2,.,n_{i}-1,..n_{W}+1,..n_\infty,t)\left&lt;\psi_{i}| T(x_k) |\psi_{W} \right&gt;     \\\\=&amp;\sum_{M} \sum_{W} n_M \bar C(n_1,n_2,.,n_{M}-1,..n_{W}+1,..n_\infty,t)\left&lt;\psi_{M}| T(x_k) |\psi_{W} \right&gt;    \end{aligned}\end{equation}\]</span></p><p>第一行代表将第一个求和变成了对所有能级求和，而第二行只是换了个变量名，使得形式更对称。同理对势能也做同样的操作，具体形式很复杂，不再赘述。</p><h1 id="粒子数表象及产生湮灭算符">粒子数表象及产生湮灭算符</h1><p>我们将前文中定义的对称波函数 $ <em>{n_1,n_2,...n</em>}(x_1,x_2,...x_n) = ()^{1/2}<em>{E_1,E_2,...E_N} </em>{E_1}(x_1) <em>{E_2}(x_2)...</em>{E_N}(x_n)<span class="math inline">\(记作\)</span>|n_1 n_2,...n_&gt;<span class="math inline">\(， 通过\)</span>_{E}(x)$的正交性很容易得到 <span class="math inline">\(\left&lt;n_1 n_2,...n_\infty |n_1&#39; n_2&#39;,...n_\infty&#39;\right&gt; = \delta_{n_1,n_1&#39;}\delta_{n_2,n_2&#39;}....\)</span>，且这组基是完备的（未证明）。</p><p>引入粒子数升降算符<span class="math inline">\(\hat b_i，\hat b^\dagger_i\)</span>，i代表对称波函数的<span class="math inline">\(n_i\)</span>对应的能级，<span class="math inline">\([\hat b_i，\hat b^\dagger_i] = 1\)</span>而不同能级之间的升降算符相互对易。</p><p>根据初量升降算符有性质<span class="math inline">\(\hat b_i\hat b^\dagger_i \left|n_1 n_2,...n_\infty\right&gt; = n_i\)</span>等。</p><p>同样的以动量作为例子，前文中推导得到的动能表达式为：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    &amp;\sum_{M} \sum_{W} n_M \bar C(n_1,n_2,.,n_{M}-1,..n_{W}+1,..n_\infty,t)\left&lt;\psi_{M}| T(x_k) |\psi_{W} \right&gt;    \\\\&amp;=\sum_{M} \sum_{W} n_M (\frac{n_1n_2...n_\infty!}{N!})^{\frac{1}{2}} (\frac{n_W+1}{n_M})^{\frac{1}{2}} f(n_1,n_2,...n_\infty) \left&lt;\psi_{M}| T(x_k) |\psi_{W} \right&gt;    \end{aligned}\end{equation}\]</span></p><p>方程左侧： <span class="math display">\[\begin{equation}    \begin{aligned}     = (\frac{n_1n_2...n_\infty!}{N!})^{\frac{1}{2}} i\hbar \frac{\partial f(n_1,n_2,...n_\infty)}{\partial t} \left|n_1 n_2,...n_\infty\right&gt;    \end{aligned}\end{equation}\]</span></p><p>综上，薛定谔方程改写为：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    &amp;i\hbar \frac{\partial f}{\partial t}\left|n_1 n_2,...n_\infty\right&gt;    =      \\\\&amp;=\sum_{M} \sum_{W} (n_W+1)^{1/2}(n_M)^{1/2} f(n_1,n_2,...n_\infty) \left&lt;\psi_{M}| T(x_k) |\psi_{W} \right&gt;\left|n_1 n_2,...n_\infty\right&gt; + etc.     \\\\&amp;=\sum_{M} \sum_{W} b_{W}^\dagger b_{M}  \left&lt;\psi_{M}| T(x_k) |\psi_{W} \right&gt;f(n_1,n_2,...n_\infty)\left|n_1 n_2,...n_\infty\right&gt; + etc.     \end{aligned}\end{equation}\]</span></p><p>势能也是同样的处理方式，所以实际上哈密顿量可以用升降算符表示为：</p><p><span class="math display">\[\begin{equation}    \begin{aligned}    \hat H = \sum_{M} \sum_{W} b_{W}^\dagger b_{M}  \left&lt;\psi_{M}| T(x_k) |\psi_{W} \right&gt; + \sum_{i,j,k,l} b_{i}^\dagger b_{j}^\dagger\left&lt; ij|V|kl \right&gt; b_{k} b_{l}    \end{aligned}\end{equation}\]</span></p><p>这种操作，将量子体系重新用升降算符来进行描述，将哈密顿量定义在了一个抽象的粒子占据数表象下。动能势能和单体本征值的内积沟通了一次量子化后的哈密顿量以及定义在抽象的粒子数表象空间中的多体哈密顿量。</p><p><mark>费米子</mark>则可以用反对易的行列式：</p><p><span class="math display">\[(\frac{n_1!n_2!..n_{\infty}!}{N!})^{1/2}\left( \begin{matrix}{l}    \psi _{E_1}\left( x_1 \right)&amp;      \cdots&amp;     \psi _{E_1}\left( x_N \right)\\\\    \vdots&amp;     \ddots&amp;     \vdots\\\\    \psi _{E_N}\left( x_1 \right)&amp;      \cdots&amp;     \psi _{E_N}\left( x_N \right)\\\\\end{matrix} \right) \]</span></p><p>作为粒子数表象所对应的波函数的表达式，同时<span class="math inline">\(\\{a_i,a_j^{\dagger}\\} = \delta_{i,j}\)</span>反对易式作为升降算符的定义，可以得到一样的表达形式。</p>]]></content>
    
    
    <categories>
      
      <category>量子力学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantum mechanics, 量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Schrieffer–Wolff transformation</title>
    <link href="/2023/02/09/quantum4/"/>
    <url>/2023/02/09/quantum4/</url>
    
    <content type="html"><![CDATA[<p>假设哈密顿量写为<span class="math inline">\(\hat{H} = \hat{H_0}+\hat{W}\)</span>, <span class="math inline">\(W\)</span>对角元等于0，且满足在<span class="math inline">\(\hat H_0\)</span>的对角化的表象下：</p><p><span class="math display">\[\left&lt;i \right|W\left| j\right&gt; &lt; \left| E_i-E_j\right|\]</span></p><p>在兼并的子空间里<span class="math inline">\(\left&lt;i \right|W\left| j\right&gt; = 0\)</span>，则可以使用S-W变换，该变换将得到一个近似的对角有效哈密顿量：</p><p>令<span class="math inline">\(U=e^{\hat S}\)</span>，则<span class="math inline">\(U HU^\dagger\)</span>等于：</p><span class="math display">\[\begin{aligned}\hat H +[\hat S,\hat H]+\frac{1}{2}[\hat S[\hat S,\hat H]]+ o\\\\= \hat H_0 +\hat W +[\hat S,\hat H_0]+[\hat S,\hat W] \\\\ + \frac{1}{2}[\hat S[\hat S,\hat H_0]]+\frac{1}{2}[\hat S[\hat S,\hat W]]\end{aligned}\]</span><p>如果该<span class="math inline">\(S\)</span>能够让<span class="math inline">\([\hat S,\hat H_0] = -\hat W\)</span>，则：</p><span class="math display">\[\begin{aligned}U HU^\dagger \approx \hat H_0 +\frac{1}{2} [\hat S,\hat W_0]\end{aligned}\]</span><p>称这样的变换为S-W变换，具体的：</p><div>令<span class="math inline">\(S = \sum_{i\ne j}\frac{V_{ij}}{E_j-E_i}\left| i\right&gt; \left&lt; j\right|\)</span>，且<span class="math inline">\(i,j\)</span>简并也=0则</div><span class="math display">\[\begin{aligned}\hat S \hat H_0 &amp;= \sum_{i\ne j}\frac{V_{ij}}{E_j-E_i}\left| i\right&gt; \left&lt; j\right| \sum_{m}E_m \left| m\right&gt; \left&lt; m \right| \\\\ &amp;= \sum_{i\ne m}\frac{V_{im}E_m}{E_j-E_m}\left| i\right&gt; \left&lt; m\right| \end{aligned}\]</span><p>同理：$H_0 S= _{im}| m&gt; &lt; i| $</p><p>因为<span class="math inline">\(V_{ij}=0\)</span>可以将求和扩充到所有的ij,最后得到对易条件：<span class="math inline">\([\hat S,\hat H_0] = -\hat W\)</span></p><p>将<span class="math inline">\(H&#39; = UHU^\dagger \approx H_0 +\frac{1}{2}[\hat S,\hat W]\)</span>的第二项视作微扰:</p><p>则<span class="math inline">\(H&#39;\)</span>在<span class="math inline">\(H_0\)</span>基下的矩阵元：</p><div style="text-align:center"><span class="math inline">\(H&#39;_{ij} = E_n \delta_{ni}\delta_{ji}+ \frac{1}{2}(\left&lt;SW \right&gt;+\left&lt; WS \right&gt;)\)</span></div><br><div style="text-align:center"><span class="math inline">\(= E_n \delta_{ni}\delta_{ji}+ \frac{1}{2}(\sum_k S_{ik}W_{kj}+W_{ik}S_{kj})\)</span></div><br><div style="text-align:center"><span class="math inline">\(= E_n \delta_{ni}\delta_{ji}+ \frac{1}{2}\sum_k W_{ik}W_{kj}(\frac{1}{d_k-d_i}+\frac{1}{d_k-d_j})\)</span></div><p>最后将<span class="math inline">\(H&#39;_{nn}\)</span>的值视作dressed energy, 视作有效哈密顿量的本征值，然后再用一阶波函数近似的方法将求得的本征态作为dress states，于是可以在对角的近似哈密顿量下讨论问题。</p><p>(有关于这种近似的有效性qutip模拟了，有空再打)</p>]]></content>
    
    
    
    <tags>
      
      <tag>量子力学,quantum physics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的一些算法</title>
    <link href="/2023/01/17/algothrim/"/>
    <url>/2023/01/17/algothrim/</url>
    
    <content type="html"><![CDATA[<blockquote><p>建议使用黑色主题</p></blockquote><h1 id="常用库">常用库</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><span class="hljs-keyword">import</span> scipy <span class="hljs-keyword">as</span> sp<br></code></pre></td></tr></table></figure><h1 id="数值计算的根本概念">1 数值计算的根本概念</h1><h2 id="浮点数的存储方法">1.1 浮点数的存储方法：</h2><p>$A = 1.5 = 2 * 0.75 = 2 * （0.5+0.25）= 2^{1} * (2<sup>{-1}+2</sup>{-2} ) $</p><table><thead><tr class="header"><th>符号位</th><th>指数位</th><th>尾数位</th></tr></thead><tbody><tr class="odd"><td>1</td><td>00000001</td><td>1100~~</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这是一个把浮点数变成float32储存字节的算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">trans_to_byte</span>(<span class="hljs-params">A</span>):<br>    <span class="hljs-keyword">if</span> A &gt;= <span class="hljs-number">0</span> :<br>        symbol = <span class="hljs-string">&quot;1&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        symbol = <span class="hljs-string">&quot;0&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;符号位:&quot;</span>,symbol)<br>    A = <span class="hljs-built_in">abs</span>(A)<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> A &gt; <span class="hljs-number">1</span>: <br>        A = A /<span class="hljs-number">2</span><br>        count+= <span class="hljs-number">1</span><br>    exp = <span class="hljs-string">&quot;&quot;</span> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>-<span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">5</span>).split(<span class="hljs-string">&quot;0b&quot;</span>)[<span class="hljs-number">1</span>])):<br>        exp = exp+<span class="hljs-string">&quot;0&quot;</span><br>    exp += <span class="hljs-built_in">bin</span>(count).split(<span class="hljs-string">&quot;0b&quot;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;指数位:&quot;</span>,exp)<br>    remain = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">24</span>):<br>        <span class="hljs-keyword">if</span> A-<span class="hljs-number">2</span>**(-i)&gt;=<span class="hljs-number">0</span>:<br>            remain = remain + <span class="hljs-string">&quot;1&quot;</span><br>            A = A - <span class="hljs-number">2</span>**(-i)<br>        <span class="hljs-keyword">else</span>:<br>            remain = remain + <span class="hljs-string">&quot;0&quot;</span><br>            A = A<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;尾数:&quot;</span>,remain)<br>    <span class="hljs-keyword">return</span>(symbol+exp+remain)<br>trans_to_byte(-<span class="hljs-number">0.55</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">符号位: 0指数位: 000000尾数: 10001100110011001100110&#39;000000010001100110011001100110&#39;</code></pre><h2 id="python的机器精度测试">1.2 python的机器精度测试</h2><!--  --><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span> + a &gt; <span class="hljs-number">1</span>:<br>    a = a/<span class="hljs-number">10</span><br>    count += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(count)<br></code></pre></td></tr></table></figure><pre><code class="hljs">16</code></pre><p>可知python的机器精度在<span class="math inline">\(10^{-16}\)</span>左右，机器精度可以理解为所能存储和操作的最小的数的单元，但是一般计算涉及不到那么小的舍入误差，</p><p>避免方法有：</p><p>1.避免过于临近的数相减</p><p>2.减少运算次数</p><p>3.尽量选取合适的单位制使得乘除法的数字在1附近</p><p>4.有一些递推算法，类似于待求值<span class="math inline">\(S_n=a*S_{n-1},a&gt;1\)</span>这种，会不断放大舍入误差，也不可取</p><h1 id="函数求值">2 函数求值</h1><h3 id="泰勒展开">2.1 泰勒展开</h3><p><span class="math inline">\(f(x)= \frac{sin(x)}{x}\)</span>类的函数在奇点（0）附近，由于舍入误差的原因，会出现不规则的震荡，这会儿需要用解析的方法对函数进行近似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.linspace(<span class="hljs-number">1e-20</span>,<span class="hljs-number">1e-15</span>,<span class="hljs-number">10000</span>)<br>y = [np.sin(i)/i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br>%matplotlib inline<br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="output_11_0.png"></p><p>numpy应该已经处理过这个问题了</p><p><span class="math inline">\(f(x) = \frac{sinx}{x}=\frac{x-\frac{x^3}{3!}...}{x} = 1 - \frac{x^2}{3!}...\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.linspace(<span class="hljs-number">1e-16</span>,<span class="hljs-number">1e-15</span>,<span class="hljs-number">10000</span>)<br>y = [<span class="hljs-number">1</span>-i**<span class="hljs-number">2</span>/np.math.factorial(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br>%matplotlib inline<br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="output_14_0.png"></p><h3 id="级数求解与阶乘求解">级数求解与阶乘求解</h3><p>一般为了简化求解，<span class="math inline">\((x -x_0)^k\)</span> 由 <span class="math inline">\((x-x_0)^{k-1}\)</span>生成，并且一般会做截断，同时阶乘会化成ln和exp的形式</p><p>$e^{0.5} = <em>{i}{}, ln(i!) = </em>{1}^i ln(n) $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.exp(<span class="hljs-number">0.5</span>))<br>diff_x = <span class="hljs-number">0.5</span> - <span class="hljs-number">0</span><br>fact_ln = <span class="hljs-number">0</span><br>diff_x_n = (<span class="hljs-number">0.5</span>-<span class="hljs-number">0</span>)**<span class="hljs-number">0</span><br>result = diff_x_n/<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">121</span>):<br>    fact_ln += np.log(i)<br>    factorial_n = np.exp(fact_ln)<span class="hljs-comment">#ln,exp生成阶乘</span><br>    diff_x_n = diff_x_n*diff_x<span class="hljs-comment">#递推生成递推公式</span><br>    result += diff_x_n/factorial_n<br>    <br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.64872127070012821.6487212707001278</code></pre><h1 id="数值计算的根本概念-1">3 数值计算的根本概念</h1><h3 id="迭代法求根">3.1 迭代法求根</h3><p>迭代法求<span class="math inline">\(x^2-5x+4=0\)</span>的根，迭代公式为<span class="math inline">\(x_n = \frac{x_{n-1}^2~~+4}{5}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_eq</span>(<span class="hljs-params">x, re_fun, tol,init_point = <span class="hljs-number">1</span></span>): <br>    step = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> init_point == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(x) != <span class="hljs-built_in">list</span>:<br>        x = [x,re_fun([x])]<br>        step = <span class="hljs-number">1</span> <span class="hljs-comment">#手动算了一个点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">abs</span>(x[-<span class="hljs-number">1</span>]-x[-<span class="hljs-number">2</span>]) <br>    <br>    <span class="hljs-keyword">while</span> (distance(x) &gt; tol):<br>        x.append(re_fun(x))<br>        step += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x,step<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_iteration</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x[-<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>+<span class="hljs-number">4</span>)/<span class="hljs-number">5</span><br><br>solve_eq(<span class="hljs-number">2</span>,fun_iteration,<span class="hljs-number">1e-5</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">([2,  1.6,  1.312,  1.1442688,  1.061870217330688,  1.0255136716907844,  1.010335658164943,  1.0041556284319177,  1.0016657052223,  1.0006668370036975,  1.000266823735797,  1.0001067437333,  1.000042699772165,  1.0000170802735202,  1.0000068321677553,  1.0000027328764378], 15)</code></pre><p>收敛条件：</p><p><span class="math inline">\(g&#39;(x)\mid_\{x_{n}\}&lt;1\)</span>时一定收敛，也就是初值点和迭代点落在<span class="math inline">\(|g&#39;(x)|&lt;1\)</span> 的区间内</p><p>prove:</p><p><span class="math inline">\(g(x)\)</span>代表迭代公式：</p><span class="math display">\[\begin{aligned}&amp;x_{i+1}-x_{i} = g(x_{i}) - g(x_{i-1}) = g(\epsilon)|x_i-x_{i-1}| \\\\ &amp;if ~ g(\epsilon) &lt;1 \Rightarrow x_{i+1}-x_{i}&lt; |x_i-x_{i-1}| \end{aligned}\]</span><p>所以所有迭代过程中取值范围内的迭代公式的导数值都小于1,迭代恒收敛(实际上还与迭代方向有关，若迭代反向，导数值迟早大于1，也有可能实际并没有解)</p><p>牛顿迭代法：<span class="math inline">\(x_{n+1} =x_{n}-f(x_n)/f&#39;(x_n)\)</span></p><p>此时<span class="math inline">\(f(x) = x^2-5x+4\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_newton</span>(<span class="hljs-params">x</span>):<br>     <span class="hljs-keyword">return</span> x[-<span class="hljs-number">1</span>]-(x[-<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>-<span class="hljs-number">5</span>*x[-<span class="hljs-number">1</span>]+<span class="hljs-number">4</span>)/(<span class="hljs-number">2</span>*x[-<span class="hljs-number">1</span>]-<span class="hljs-number">5</span>)<br>solve_eq(<span class="hljs-number">2</span>,fun_newton,<span class="hljs-number">1e-10</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">([2,  0.0,  0.8,  0.9882352941176471,  0.9999542229343099,  0.9999999993015081,  1.0,  1.0], 7)</code></pre><p>弦截法：(用差商代替微商)：<span class="math inline">\(x_{n+1} =x_{n}-f(x_n)\frac{x_k-x_{k-1}}{f(x_k)-f(x_{k-1})}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x**<span class="hljs-number">2</span>-x*<span class="hljs-number">5</span>+<span class="hljs-number">4</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_string</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[-<span class="hljs-number">1</span>]-(x[-<span class="hljs-number">1</span>]-x[-<span class="hljs-number">2</span>])/(f(x[-<span class="hljs-number">1</span>])-f(x[-<span class="hljs-number">2</span>]))*f(x[-<span class="hljs-number">1</span>])<br>solve_eq([<span class="hljs-number">2</span>,<span class="hljs-number">1.8</span>],fun_string,<span class="hljs-number">1e-10</span>,init_point = <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">([2,  1.8,  0.33333333333333526,  1.1860465116279069,  1.0356347438752782,  0.9976137655897542,  1.000028661939602,  1.0000000227801336,  0.9999999999997824,  1.0], 8)</code></pre><h1 id="函数插值">4 函数插值</h1><h3 id="拉格朗日插值">4.1 拉格朗日插值</h3><p><span class="math inline">\(\phi(x) = y_0 l_0(x)+ y_1 l_1(x) + y_2 l_2(x) + y_3 l_3(x)...\)</span></p><p><span class="math inline">\(l_i(x) = \frac{(x-x_0)(x-x_1)...(x-x_n)}{(x_i-x_0)(x_i-x_1)..(x_i-x_n)}\)</span></p><p>插目标函数：<span class="math inline">\(f(x) = e^{2x} - x^2\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># scipy的拉格朗日插值</span><br><span class="hljs-keyword">from</span> scipy.interpolate <span class="hljs-keyword">import</span> lagrange<br>x=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br>y = np.exp(<span class="hljs-number">2</span>*x)-x**<span class="hljs-number">2</span><br>poly = lagrange(x, y)<br>x1 = np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">#手算的插值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lagrange_dyf</span>(<span class="hljs-params">x,y,x_target</span>):<br>    result = <span class="hljs-number">0</span><br>    component = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        tem = <span class="hljs-number">1</span><br>        <span class="hljs-comment">#计算第n个插值多项式</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,i):<br>            tem *= (x_target - x[j])/(x[i] - x[j])<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(x)):<br>            tem *= (x_target - x[j])/(x[i] - x[j])<br>        tem *= y[i]<br>        result += tem<br>    <span class="hljs-keyword">return</span> result<br><br>%matplotlib inline<br>fig, ax = plt.subplots(<span class="hljs-number">1</span>)<br>plt.scatter(x,y,label =<span class="hljs-string">&quot;data&quot;</span>)<br>plt.plot(x1,[poly(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x1],label = <span class="hljs-string">r&quot;interpolate curve created by scipy&quot;</span>,linestyle = <span class="hljs-string">&quot;--&quot;</span>)<br>plt.plot(x1,[lagrange_dyf(x,y,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x1],label = <span class="hljs-string">r&quot;interpolate_curve&quot;</span>,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>ax.legend();  <span class="hljs-comment"># Add a legend.</span><br>ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)  <span class="hljs-comment"># Add an x-label to the axes.</span><br>ax.set_ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)  <span class="hljs-comment"># Add a y-label to the axes.</span><br>ax.set_title(<span class="hljs-string">&quot;lagrange&quot;</span>)  <span class="hljs-comment"># Add a title to the axes.</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="output_31_0.png"></p><h3 id="牛顿插值">4.2 牛顿插值</h3><p>插值表达式为:</p><span class="math display">\[\begin{aligned}p(x) = f\[x_0\](x-x_0) +  f\[x_0,x_1\](x-x_0)(x-x_1) \\\\+ f\[x_0,x_1,x_2\](x-x_0)(x-x_1)(x-x_2)...\end{aligned}\]</span><p>优势在于便于扩展，每次多一个数据点，不用重新算插值系数和插值基，同时插值基的大小顺序没有关系，插值系数有对称性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Newton_interpolate_dyf</span>(<span class="hljs-params">x,y,x_target</span>):<br>    func = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(x,y))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ceff</span>(<span class="hljs-params">X</span>): <span class="hljs-comment"># 得到 f[x0,x1,x2..xn]的函数,X是一个[x0,x1,x2,..xn]的列表</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(X)==<span class="hljs-number">1</span> :<br>            <span class="hljs-keyword">return</span>  func[X[<span class="hljs-number">0</span>]] <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span>  (get_ceff(X[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(X)]) - get_ceff(X[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(X)-<span class="hljs-number">1</span>]))/(X[-<span class="hljs-number">1</span>]-X[<span class="hljs-number">0</span>])<br>    result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(x)):<br>       <span class="hljs-comment"># print(&#x27;在算第&#x27;+str(i+1)+&#x27;个项，系数为&#x27;,x[0:i+1])</span><br>        poly = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,i):<br>            poly *= x_target-x[j]<br>       <span class="hljs-comment"># print(&quot;多&quot;,poly,x[i],x_target)</span><br>        result += get_ceff(x[<span class="hljs-number">0</span>:i+<span class="hljs-number">1</span>])*poly<br>        <span class="hljs-comment">#print(result)</span><br>    <span class="hljs-keyword">return</span> result<br><br>x=np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br>y = (np.exp(<span class="hljs-number">2</span>*x)-x**<span class="hljs-number">2</span>).tolist()<br>x = x.tolist()<br>x1 = np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>)<br><br>%matplotlib inline<br>fig, ax = plt.subplots(<span class="hljs-number">1</span>)<br>plt.scatter(x,y,label =<span class="hljs-string">&quot;data&quot;</span>)<br>plt.plot(x1,[Newton_interpolate_dyf(x,y,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x1],label = <span class="hljs-string">r&quot;interpolate curve&quot;</span>,color = <span class="hljs-string">&quot;pink&quot;</span>)<br>ax.legend();  <span class="hljs-comment"># Add a legend.</span><br>ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)  <span class="hljs-comment"># Add an x-label to the axes.</span><br>ax.set_ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)  <span class="hljs-comment"># Add a y-label to the axes.</span><br>ax.set_title(<span class="hljs-string">&quot;Newton&quot;</span>)  <span class="hljs-comment"># Add a title to the axes.</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="output_34_0.png"></p><h1 id="数值积分">5 数值积分</h1><h3 id="简单积分方法梯形积分">5.1 简单积分方法：梯形积分</h3><p>积分公式：</p><p><span class="math display">\[T = \sum_{i}{(f(x_i)+f(x_{i+1}))\frac{\Delta x_i}{2}}\]</span></p><p>误差分析：</p><p>某一个矩形积分区间中：</p><span class="math display">\[\begin{aligned}&amp;T_{theory} - T_{numerical} = F(x_{i+1})-F(x_i) - (f(x_i)+f(x_{i+1}))\frac{\Delta x_i}{2}\\\\ &amp;= F&#39;(x_i) \Delta x_i +\frac{1}{2}F&#39;&#39;(x_i) \Delta x_i ^2 + \frac{1}{6}F&#39;&#39;&#39;(x_i)\Delta x_i ^3 - f(x_i)\Delta x_i \\\\&amp;- \frac{1}{2} f&#39;(x_i)\Delta x_i ^2 -\frac{1}{4}f&#39;&#39;(x_i)\Delta x_i ^3\\\\ &amp;= \frac{1}{12} f&#39;&#39;(x_i) \Delta x_i ^3\end{aligned}\]</span><p><span class="math inline">\(F(x)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的原函数，第二行来源于在<span class="math inline">\(x_{i+1}\)</span>的泰勒展开，所以将所有梯形分区的误差加一起后得到最大误差上限<span class="math inline">\((b-a)\frac{w^3}{12}M\)</span>，<span class="math inline">\(M\)</span>为f(x)导数区间的最大值，w是分割长度，b,a,积分上下限</p><blockquote><p>物理中常用的积分与求和相互转换 <span class="math inline">\(\int_a^b f(x)dx = \frac{(b-a)}{N}\sum_i^N f(x_i),x_i = a+\frac{b-a}{N} i= \sum_i^N f(x_i) \Delta V\)</span>,转换成了求面积</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#f(x) = sin(x) a = 0 ,b = pi</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">intergrate_Trapezoid</span>(<span class="hljs-params">func,a,b,N</span>):<br>    x = np.linspace(a,b,N)<br>    w = (b-a)/N<br>    y = [func(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br>    T = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)-<span class="hljs-number">1</span>):<br>        T += (y[i] + y[i+<span class="hljs-number">1</span>])*w/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> T<br><span class="hljs-built_in">print</span>(intergrate_Trapezoid(np.sin,<span class="hljs-number">0</span>,np.pi,<span class="hljs-number">100000</span>))<br><br><span class="hljs-keyword">import</span> scipy.integrate <span class="hljs-keyword">as</span> integrate<br><span class="hljs-built_in">print</span>(integrate.quad(np.sin,<span class="hljs-number">0</span>,np.pi))<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.9999799998355314(2.0, 2.220446049250313e-14)</code></pre><h3 id="辛普森积分公式">5.2 辛普森积分公式</h3><p>推导：</p><p>由三点插值的拉格朗日插值公式：</p><span class="math display">\[\begin{aligned}p(x) =&amp; f(x_0) \frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)} \\\\&amp; + f(x_1) \frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)} \\\\&amp;+ f(x_2) \frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\end{aligned}\]</span><p>取<span class="math inline">\(x_1\)</span>在<span class="math inline">\(x_0\)</span>和<span class="math inline">\(x_2\)</span>的中点，计算<span class="math inline">\(\int^{x_2}_{x_0}p(x)dx\)</span>为：</p><p><span class="math display">\[I = \frac{x_2-x_0}{6}[f(x_0)+4f(x_1)+f(x_2)]\]</span></p><p>误差分析方法同上，就不写了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">intergrate_simpson</span>(<span class="hljs-params">func,a,b,N</span>):<br>    x = np.linspace(a,b,N)<br>    w = (b-a)/N<br>    T = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)-<span class="hljs-number">1</span>):<br>        T += (func(x[i])+<span class="hljs-number">4</span>*func((x[i]+x[i+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>)+func(x[i+<span class="hljs-number">1</span>]))*w/<span class="hljs-number">6</span><br>    <span class="hljs-keyword">return</span> T<br><br><span class="hljs-built_in">print</span>(intergrate_simpson(np.sin,<span class="hljs-number">0</span>,np.pi,<span class="hljs-number">1000000</span>))<br><br><span class="hljs-keyword">import</span> scipy.integrate <span class="hljs-keyword">as</span> integrate<br><span class="hljs-built_in">print</span>(integrate.quad(np.sin,<span class="hljs-number">0</span>,np.pi))<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.9999980000000428(2.0, 2.220446049250313e-14)</code></pre><p>高阶积分公式及隆贝格积分略</p><h3 id="高斯积分公式">5.3 高斯积分公式</h3><p>可以用多项式去插值对应的待积分函数，并且通过变量代换变到<span class="math inline">\([-1,1]\)</span>的区间上通过几个关键的函数点(高斯点)对插值的多项式进行求解。</p><p>以两点高斯积分为例：</p><span class="math display">\[\begin{aligned}&amp;p(-\frac{1}{\sqrt{3}})+ p(\frac{1}{\sqrt{3}}) = \int^1_{-1} p(x) dx\\\\&amp;p(x) = ax^3+bx^2+cx+d \end{aligned}\]</span>则求积分的思路变为：<div style="text-align:center"><span class="math inline">\(\int^b_a f(x)dx = \sum^{i} \int^{x_i+w}_{x_i}f(x)dx\)</span></div><br><div style="text-align:center"><span class="math inline">\(= \sum^{i} \int^{1}_{-1}\frac{w}{2} f(\frac{w}{2}x&#39;+x_i+\frac{w}{2})dx&#39;\)</span></div><br><div style="text-align:center"><span class="math inline">\(\approx \sum_{i} \frac{w}{2}(f(\frac{w}{2}\frac{1}{\sqrt 3}+x_i+\frac{w}{2})+f(-\frac{w}{2}\frac{1}{\sqrt 3}+x_i+\frac{w}{2}))\)</span></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.special <span class="hljs-keyword">import</span> roots_legendre <span class="hljs-comment">#用于得到对应的高斯点 </span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">integrate_gauss</span>(<span class="hljs-params">func,a,b,N</span>):<br>    x = np.linspace(a,b,N)<br>    w = (b-a)/N<br>    T = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)-<span class="hljs-number">1</span>):<br>        T += w/<span class="hljs-number">2</span>*(func(w/<span class="hljs-number">2</span>/np.sqrt(<span class="hljs-number">3</span>)+x[i]+w/<span class="hljs-number">2</span>)+func(-w/<span class="hljs-number">2</span>/np.sqrt(<span class="hljs-number">3</span>)+x[i]+w/<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> T<br><span class="hljs-built_in">print</span>(integrate_gauss(np.sin,<span class="hljs-number">0</span>,np.pi,<span class="hljs-number">100000</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">integrate_gauss_n</span>(<span class="hljs-params">func,a,b,N,n</span>):<span class="hljs-comment">#n是高斯点的个数</span><br>    x = np.linspace(a,b,N)<br>    w = (b-a)/N<br>    T = <span class="hljs-number">0</span><br>    x_gauss,a = roots_legendre(n) <span class="hljs-comment"># scipy可以方便得到高斯点w以及对应的权重a</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x_gauss)):<br>            T += a[j]*w/<span class="hljs-number">2</span>*func(w/<span class="hljs-number">2</span>*x_gauss[j]+x[i]+w/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> T<br><span class="hljs-built_in">print</span>(integrate_gauss_n(np.sin,<span class="hljs-number">0</span>,np.pi,<span class="hljs-number">100000</span>,<span class="hljs-number">5</span>))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">1.99997999999999831.9999800000000323</code></pre><h3 id="反常积分的求解">5.4 反常积分的求解</h3><h4 id="解析处理">5.4.1 解析处理</h4><p>换元法对奇点降阶，(小于1阶的都可以)</p><p><span class="math display">\[\int^{\frac{\pi}{2}}_0 \frac{f(x)}{\sqrt x} dx = \int^{\sqrt \frac{\pi}{2}}_0 \frac{f(x(u))}{u} 2u du\]</span></p><p>如果积分两端都是奇点，可以将区间分割成两部分分别求解,用分布积分等处理</p><h4 id="分布积分">5.2.分布积分</h4><p>如<span class="math inline">\(\int_{\epsilon}^a f(x)/x dx\)</span>型的，$^{}_{x}f(x) <span class="math inline">\(,因为积分下限太小时可能算不准，需要将积分变形提出\)</span>ln()$的表达式</p><span class="math display">\[\begin{aligned}\int_{\epsilon}^a \frac{sinx}{x^2}dx &amp;= \int_{\epsilon}^a \frac{sinx/x}{x} dx \\\\&amp;= \int_{\epsilon}^a \frac{sinx/x-1}{x} dx +\int_{\epsilon}^a \frac{1}{x} dx \\\\&amp;=  \int_{\epsilon}^{\delta} \frac{sinx/x-1}{x} dx + \int_{\delta}^a \frac{sinx/x-1}{x} dx \\\\&amp;+ \ln(a) -\ln(\epsilon)\\\\&amp;= \int_{\epsilon}^{\delta} \frac{1- 1 + \frac{1}{3!}x^3 - \frac{1}{5!}x^5 ..}{x} dx + \\\\&amp;\int_{\delta}^a \frac{sinx/x-1}{x} dx + \ln(a) -\ln(\epsilon)\end{aligned}\]</span><p>若是有无穷区间的积分，不能简单截断，因为不能证明后面的积分是可忽略的量，而是要通过换元的方法去积分</p><h1 id="有限离散傅里叶变换">有限离散傅里叶变换</h1><p>f(t)是<span class="math inline">\([0,t_{end}]\)</span>区间上的函数</p><p>变换公式：</p><p><span style="text-align:center"></p><p><span class="math inline">\(F(w_n) = \sum^{N-1}_{l=0}f(t_l) e^{-i\frac{2\pi l}{N}}\)</span></p><p><span class="math inline">\(f(t_l) = \sum^{N-1}_{k=0}F(w_n) e^{i\frac{2\pi n}{N}}\)</span></p><p></span></p><p>该变换主要用于频谱分析.需要的量为<span class="math inline">\(|{F(w_l)}|\)</span>，与傅里叶变换<span class="math inline">\(F(w_l)\)</span>相比，该变换相差一个常数因子，见<a href="https://www.zhihu.com/question/21314374/answer/2361985353">知乎回答</a></p><p>横坐标对应于<span class="math inline">\(w_l= \frac{2\pi l }{N\Delta t}\)</span>，<span class="math inline">\(\Delta t\)</span>为取样间隔</p><p>将 $f(t) =e<sup>{-200t</sup>2} $ 做DFT变换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">t_end = <span class="hljs-number">1</span><br>N = <span class="hljs-number">400</span> <span class="hljs-comment">#不能少于两个点</span><br>t = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*np.pi*t_end,N)<span class="hljs-comment">#是等距的点</span><br>delta_t = t[<span class="hljs-number">1</span>] - t[<span class="hljs-number">0</span>] <br>y = np.exp(-t**<span class="hljs-number">2</span>*<span class="hljs-number">200</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DFT_trans</span>(<span class="hljs-params">f</span>):<span class="hljs-comment">#f是传入其中的采样点的np.array</span><br>    F = <span class="hljs-built_in">list</span>()<br>    N = <span class="hljs-built_in">len</span>(f)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        tem = <span class="hljs-number">0</span> <span class="hljs-comment">#容器</span><br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>            tem += f[l]*np.exp(-<span class="hljs-number">1.j</span>*k*<span class="hljs-number">2</span>*np.pi*l/N)<br>        F.append(tem)<br>    <span class="hljs-keyword">return</span> np.array(F)   <br><br><span class="hljs-keyword">import</span> scipy.fft <span class="hljs-keyword">as</span> fft<br>N = <span class="hljs-built_in">len</span>(y)<br><span class="hljs-comment">#fft.fft(y)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">w0 = np.linspace(-<span class="hljs-number">2</span>*np.pi/delta_t,<span class="hljs-number">0</span>,N)<br>w1 = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*np.pi/delta_t,N)<br>%matplotlib inline<br>fig, ax = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-comment">#plt.scatter(x,y,label =&quot;data&quot;)</span><br>ax[<span class="hljs-number">0</span>].plot(w1,<span class="hljs-built_in">abs</span>(fft.fft(y)),label = <span class="hljs-string">r&quot;FFT by Scipy&quot;</span>,color=<span class="hljs-string">&quot;blue&quot;</span>,linestyle = <span class="hljs-string">&quot;--&quot;</span>)<br>ax[<span class="hljs-number">0</span>].plot(w0,<span class="hljs-built_in">abs</span>(fft.fft(y)),color=<span class="hljs-string">&quot;blue&quot;</span>)<br>ax[<span class="hljs-number">0</span>].plot(w0,<span class="hljs-built_in">abs</span>(DFT_trans(y)),label = <span class="hljs-string">r&quot;DFT&quot;</span>,color=<span class="hljs-string">&quot;red&quot;</span>,linestyle = <span class="hljs-string">&quot;-.&quot;</span>)<br>ax[<span class="hljs-number">0</span>].plot(w1,<span class="hljs-built_in">abs</span>(DFT_trans(y)),color=<span class="hljs-string">&quot;red&quot;</span>)<br>ax[<span class="hljs-number">0</span>].legend();  <span class="hljs-comment"># Add a legend.</span><br>ax[<span class="hljs-number">0</span>].set_xlabel(<span class="hljs-string">&#x27;w&#x27;</span>)  <span class="hljs-comment"># Add an x-label to the axes.</span><br>ax[<span class="hljs-number">0</span>].set_ylabel(<span class="hljs-string">&#x27;F\&#x27;(w)&#x27;</span>)  <span class="hljs-comment"># Add a y-label to the axes.</span><br>ax[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&quot;DFT transforms&quot;</span>)  <span class="hljs-comment"># Add a title to the axes.</span><br><br><span class="hljs-comment">## 更改点数后再画</span><br>N = <span class="hljs-number">200</span> <span class="hljs-comment">#不能少于两个点</span><br>t = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*np.pi*t_end,N)<span class="hljs-comment">#是等距的点</span><br>delta_t = t[<span class="hljs-number">1</span>] - t[<span class="hljs-number">0</span>] <br>y = np.exp(-t**<span class="hljs-number">2</span>*<span class="hljs-number">200</span>)<br>w0 = np.linspace(-<span class="hljs-number">2</span>*np.pi/delta_t,<span class="hljs-number">0</span>,N)<br>w1 = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*np.pi/delta_t,N)<br><br>ax[<span class="hljs-number">1</span>].plot(w1,<span class="hljs-built_in">abs</span>(fft.fft(y)),label = <span class="hljs-string">r&quot;FFT by Scipy&quot;</span>,color=<span class="hljs-string">&quot;blue&quot;</span>,linestyle = <span class="hljs-string">&quot;--&quot;</span>)<br>ax[<span class="hljs-number">1</span>].plot(w0,<span class="hljs-built_in">abs</span>(fft.fft(y)),color=<span class="hljs-string">&quot;blue&quot;</span>)<br>ax[<span class="hljs-number">1</span>].plot(w0,<span class="hljs-built_in">abs</span>(DFT_trans(y)),label = <span class="hljs-string">r&quot;DFT&quot;</span>,color=<span class="hljs-string">&quot;red&quot;</span>,linestyle = <span class="hljs-string">&quot;-.&quot;</span>)<br>ax[<span class="hljs-number">1</span>].plot(w1,<span class="hljs-built_in">abs</span>(DFT_trans(y)),color=<span class="hljs-string">&quot;red&quot;</span>)<br>ax[<span class="hljs-number">1</span>].legend();  <span class="hljs-comment"># Add a legend.</span><br>ax[<span class="hljs-number">1</span>].set_xlabel(<span class="hljs-string">&#x27;w&#x27;</span>)  <span class="hljs-comment"># Add an x-label to the axes.</span><br>ax[<span class="hljs-number">1</span>].set_ylabel(<span class="hljs-string">&#x27;F\&#x27;(w)&#x27;</span>)  <span class="hljs-comment"># Add a y-label to the axes.</span><br>ax[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&quot;DFT transforms&quot;</span>)  <span class="hljs-comment"># Add a title to the axes.</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="output_50_0.png"></p><p>由于是<span class="math inline">\(f&#39;(w)\)</span>是周期函数，所以出现的峰值不一定就是正确的，需要更改取点数的多少从而更改w的范围从而更改<span class="math inline">\(f&#39;(w)\)</span>的周期来判断是不是真峰，没有移动的峰才是真峰，显然0点附近的高斯波包才是真峰。</p><h1 id="矩阵求解之lu分解">矩阵求解之LU分解</h1><p>若矩阵<span class="math inline">\(A=LU\)</span>,则求解<span class="math inline">\(Ax=b\)</span>可转换成<span class="math inline">\(Ly=b\)</span>再求解<span class="math inline">\(Ux = y\)</span>，<span class="math inline">\(L\)</span>为下三角矩阵，<span class="math inline">\(U\)</span>为上三角矩阵</p><h2 id="cholesky-分解">Cholesky 分解</h2><p>根据计算数学理论，一个正定对称矩阵一定可以做LU分解</p>由：<div><p><span class="math display">\[\hat{A}_{ii} = \left( \begin{matrix}    a_{ii}&amp;     \alpha\\\\    \alpha ^T&amp;      A_{i+1i+1}\end{matrix} \right) \]</span></p></div><p><br></p><div><p><span class="math display">\[\,\,=\,\,\left( \begin{matrix}    u_{ii}&amp;     0\\\\    u^T&amp;        {U_{i+1i+1}}^T\end{matrix} \right) \left( \begin{matrix}    u_{ii}&amp;     u\\\\    0&amp;      U_{i+1i+1}\end{matrix} \right) \]</span></p></div><p>得到具体算法：</p><span class="math display">\[\begin{aligned}&amp;u_{ii} = \sqrt{a_{11}}\\\\&amp;u_{ij} = \frac{a_{ij}}{a_{ii}} \end{aligned}\]</span><div style="text-align:center"><span class="math inline">\(\hat{A}_{i+1i+1}=U_{i+1i+1}^T U_{i+1i+1} = A_{i+1i+1}-u^Tu\)</span></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Cholesky_factorization</span>(<span class="hljs-params">A</span>):<span class="hljs-comment">#A是对角正定矩阵</span><br>    U = np.zeros(A.shape)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,A.shape[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>): <span class="hljs-comment">#只用遍历到倒数第二行</span><br>        U[i][i] = np.sqrt(A[i][i])<br>        u_vec = A[i][i+<span class="hljs-number">1</span>:A.shape[<span class="hljs-number">1</span>]]/U[i][i]<br>        tem = np.zeros(A.shape[<span class="hljs-number">1</span>] - u_vec.shape[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 用于对A操作，得到Ahat</span><br>        u_vec = np.append(tem,u_vec)<br>        A = A - np.outer(u_vec,u_vec) <span class="hljs-comment">#将A hat用A右下角来储存</span><br>        U[i] = U[i]+ u_vec <br>        U[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] = np.sqrt(A[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> U<br>A = np.array([[<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;U矩阵：\n&quot;</span>,Cholesky_factorization(A))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;L矩阵：\n&quot;</span>,np.linalg.cholesky(A)) <span class="hljs-comment"># numpy自带的分解</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">U矩阵： [[ 1.73205081 -0.57735027  0.57735027] [ 0.          1.63299316  0.20412415] [ 0.          0.          1.62018517]]L矩阵： [[ 1.73205081  0.          0.        ] [-0.57735027  1.63299316  0.        ] [ 0.57735027  0.20412415  1.62018517]]</code></pre><p>求解方程：</p><p><span class="math display">\[\left[ \begin{matrix}    1&amp;      3&amp;      1\\\\    3&amp;      10&amp;     4\\\\    1&amp;      4&amp;      4\\\\\end{matrix} \right] \left[ \begin{array}{c}    x_1\\\\    x_2\\\\    x_3\\\\\end{array} \right] =\\,\\,\left[ \begin{array}{c}    0\\\\    2\\\\    -\frac{1}{3}\\\end{array} \right] \]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">A =np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]])<br>U = Cholesky_factorization(A)<br>L = U.transpose()<br>b = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>/<span class="hljs-number">3</span>])<br><span class="hljs-comment">#先求解y</span><br>y = [b[<span class="hljs-number">0</span>]/L[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]] <span class="hljs-comment">#先把y1处理了</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(b)):<br>    tem = b[i]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,i):<br>        tem = tem - L[i][j]*y[j]<br>    tem = tem/L[i][i]<br>    y.append(tem)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y:&quot;</span>,y)<br><span class="hljs-comment">#求解x</span><br>x = np.zeros(<span class="hljs-built_in">len</span>(y))<br>x[-<span class="hljs-number">1</span>] = y[-<span class="hljs-number">1</span>]/U[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<span class="hljs-comment">#先把y1处理了</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>    tem = y[i]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y)-<span class="hljs-number">1</span>,i,-<span class="hljs-number">1</span>):<br>        tem = tem - U[i][j]*x[j]<br>    tem = tem/U[i][i]<br>    x[i] = tem<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x:&quot;</span>,x)<br></code></pre></td></tr></table></figure><pre><code class="hljs">y: [0.0, 2.0, -1.6499158227686108]x: [-8.33333333  3.16666667 -1.16666667]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#numpy自带的求解线性方程组</span><br>y = np.linalg.solve(L,b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y:&quot;</span>,y)<br>x = np.linalg.solve(U,y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x:&quot;</span>,x)<br>x_prime = np.linalg.solve(A,b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;直接计算x:&quot;</span>,x_prime)<br></code></pre></td></tr></table></figure><pre><code class="hljs">y: [ 0.          2.         -1.64991582]x: [-8.33333333  3.16666667 -1.16666667]直接计算x: [-8.33333333  3.16666667 -1.16666667]</code></pre><h3 id="高斯消去法得lu分解">2. 高斯消去法得LU分解</h3><p>假设<span class="math inline">\(A\)</span>通过<span class="math inline">\(n\)</span>次消去操作后变为上三角矩阵<span class="math inline">\(U\)</span>，既：</p><span class="math display">\[\begin{aligned}&amp;L_1^{-1}..L_{n-1}^{-1}L_n^{-1}L_nL_{n-1}...L_1 A \\\\&amp;= S (L_nL_{n-1}...L_1 A) = SU = A\\\\&amp;S= L_1^{-1}..L_{n-1}^{-1}L_n^{-1} \end{aligned}\]</span><p>由消去操作对应的变换矩阵为下三角矩阵，且容易证明下三角矩阵的乘积仍然是下三角矩阵，可知S是下三角矩阵</p><p>同时容易证明<span class="math inline">\(S_{ij}= \frac{a_{ii}}{a_{ij}}\)</span>，通过矩阵的分量乘积表达式以及消去法的变换矩阵的特征易得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#假设是A是full pivoting的，也就是恰当排序使得在分解过程中不存在对角元为0的情况</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gauss_elimination_LU</span>(<span class="hljs-params">A</span>):<br>    <span class="hljs-comment">#a是系数矩阵，b是方程的非齐次值,a得满足一定条件,先将a分解成LU矩阵</span><br>    N = A.shape[<span class="hljs-number">0</span>]<br>    L = np.identity(N)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,N):<br>        <span class="hljs-keyword">if</span> A[i][i] != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,N):<span class="hljs-comment">#消去</span><br>                <span class="hljs-keyword">if</span> A[i][j] != <span class="hljs-number">0</span>:<br>                    tem = A[i][j]/A[i][i]<br>                    A[j] = A[j] - tem*A[i]<br>                    L[j][i] = tem<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A不是恰当排序的&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> L,A<br></code></pre></td></tr></table></figure><h1 id="求解实矩阵的本征值">求解实矩阵的本征值</h1><h2 id="householder变换">Householder变换</h2><p>存在向量<span class="math inline">\(\left|w \right&gt;\)</span>与<span class="math inline">\(\left|e_0 \right&gt;\)</span>，欲找到映射<span class="math inline">\(H\)</span>，使得<span class="math inline">\(H \left|w \right&gt; = ||w||\left|e_0 \right&gt;\)</span>，这个映射被定义为Householder变换，容易验证：</p><span class="math display">\[\begin{aligned}H &amp;= I - \frac{2\left| v\right&gt;\left&lt; v \right|}{\left&lt; v|v \right&gt;} \\\\v &amp;= \left|w \right&gt; \pm ||w||\left|e_0 \right&gt;\end{aligned}\]</span><p>同时也容易验证<span class="math inline">\(HH = I,H^T = H\)</span></p><h2 id="qr分解">QR分解</h2><p>矩阵<span class="math inline">\(A_0\)</span>的第一行列向量为<span class="math inline">\(w\)</span>，<span class="math inline">\(e_0\)</span>为矩阵的基矢量，则可以得到<span class="math inline">\(H_0A_0 = A_1\)</span>，<span class="math inline">\(A_1\)</span>的第一行列向量除了00元都为0，再考虑<span class="math inline">\(U_1 = e_1 \oplus e_2...\oplus e_n\)</span>空间以及<span class="math inline">\(A_1&#39; = A_1 \mid_{U_1}\)</span>，同样的操作得到子空间上的<span class="math inline">\(H_1&#39;A_1&#39; = A_2&#39;\)</span>，<span class="math inline">\(H_1&#39;\)</span>是子空间上的映射,在子空间的矩阵表达式中除了11元都为0，令<span class="math inline">\(H_1 e_i = H_1&#39;e_i \enspace i&gt;0, H_1 e_0 = e_0\)</span>，则可得到<span class="math inline">\(H_1H_0 A_0 = A_2\)</span>，<span class="math inline">\(A_2\)</span>的前两列的下三角元都为0，同样的方法，最终<span class="math inline">\(n\)</span>步后，得到上三角矩阵<span class="math inline">\(A_n\)</span>，以及<span class="math inline">\(H_nH_{n-1}...H_{0}A_0 = A_n\)</span>，再由<span class="math inline">\(H\)</span>的性质得到<span class="math inline">\(A_0 = H_0H_1...H_nA_n\)</span>，于是得到正交矩阵<span class="math inline">\(Q=H_0H_1...H_n\)</span>和上三角矩阵<span class="math inline">\(R = A_n\)</span></p><h2 id="求解特征值">求解特征值</h2><p>想要求实矩阵<span class="math inline">\(A_i\)</span>的本征值，对<span class="math inline">\(A_i=QR\)</span>做合同变换<span class="math inline">\(A_{i+1}=QQRQ^T = RQ\)</span>，则<span class="math inline">\(A_i\)</span>的本征值全都相同，由一个数学理论可以得到，<span class="math inline">\(i\rightarrow \infty\)</span>时，<span class="math inline">\(A_i\)</span>趋近于上三角矩阵，再由上三角矩阵的对角元既为特征值</p><p>留一个我参考的文章</p><p><a href="NotesOnHouseholderQR.pdf">Notes on Householder QR Factorization</a> 侵删</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">QR_factorization</span>(<span class="hljs-params">A</span>):<span class="hljs-comment">#为了简单，这里讨论实数矩阵</span><br>    A = np.array(A,dtype=<span class="hljs-built_in">float</span>)<br>    N = A.shape[<span class="hljs-number">0</span>]<br>    Householder_Matrix = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N-<span class="hljs-number">1</span>):     <span class="hljs-comment">#来源于参考文献</span><br>        <span class="hljs-comment">#print(A[i:,i])</span><br>        alpha = np.linalg.norm(A[i:,i])<br>        signi = np.sign(A[i][i])<br>        rho = -signi * alpha<br>        nu1 = A[i][i] - rho <br>        u2 = A[i+<span class="hljs-number">1</span>:,i]/nu1<br>        tau = (<span class="hljs-number">1</span> + np.dot(u2,u2))/<span class="hljs-number">2</span><br>        <span class="hljs-comment">#记录使用的Householder变换的矩阵</span><br>        tem_matrix = np.identity(N,dtype = <span class="hljs-built_in">float</span>)<br>        tem_matrix[i:,i:] = np.identity(N-i) - np.outer(np.insert(u2,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),np.insert(u2,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))/tau<br>        Householder_Matrix.append(tem_matrix)<br>        <span class="hljs-comment">#print(Householder_Matrix[-1])</span><br>        <span class="hljs-comment">#print(np.matmul(Householder_Matrix[-1],A))</span><br>        <span class="hljs-comment">#手动求解变换后的对角矩阵，减少矩阵运算的次数</span><br>        A[i][i] = rho<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,N):<br>            A[j][i] = <span class="hljs-number">0</span><br>        w12T = (A[i,i+<span class="hljs-number">1</span>:] + np.matmul(A[i+<span class="hljs-number">1</span>:,i+<span class="hljs-number">1</span>:],u2))/tau<br>        A[i,i+<span class="hljs-number">1</span>:] = A[i,i+<span class="hljs-number">1</span>:] - w12T <br>        A[i+<span class="hljs-number">1</span>:,i+<span class="hljs-number">1</span>:] = A[i+<span class="hljs-number">1</span>:,i+<span class="hljs-number">1</span>:] - np.outer(u2,w12T)<br>        Q = np.identity(N)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> Householder_Matrix:<br>            Q = np.matmul(Q,j)<br>    <span class="hljs-keyword">return</span> Q,A<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">A = np.array([[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eigen_values</span>(<span class="hljs-params">A</span>):<span class="hljs-comment">#A是一个有特征值的实矩阵，没写判断条件,所以用的实对称矩阵检验</span><br>    tol = <span class="hljs-number">1</span><br>    N = A.shape[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10000</span>):<br>        tol = <span class="hljs-number">0</span><br>        Q,R = QR_factorization(A)<br>        A = np.matmul(R,Q)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,N):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N-<span class="hljs-number">1</span>,i,-<span class="hljs-number">1</span>):<br>                tol += np.<span class="hljs-built_in">abs</span>(A[j][i])<br>    <span class="hljs-keyword">return</span> np.array([A[i][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)])<br><span class="hljs-built_in">print</span>(get_eigen_values(A))<br>np.linalg.eigvals(A)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[8.11753167 2.13093256 0.75153577]array([8.11753167, 0.75153577, 2.13093256])</code></pre>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computing science,计算数学，计算物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>含时微扰和跃迁</title>
    <link href="/2023/01/05/quantum3/"/>
    <url>/2023/01/05/quantum3/</url>
    
    <content type="html"><![CDATA[<h1 id="含时微扰">含时微扰</h1><p>在相互作用表象下，薛定谔方程写为：</p><p><span class="math inline">\(i \hbar \dot U_I = V_I U_I，U_I(t = 0) = I\)</span></p><p>于是将<span class="math inline">\(U_I\)</span>积出来，得到：</p><span class="math display">\[\begin{aligned}U_I &amp;= I + \frac{1}{i \hbar}\int_{0}^{t} V_IU_Idt\\\\&amp;= I + \frac{1}{i \hbar}\int_{0}^{t} V_Idt \\\\&amp;+ (\frac{1}{i \hbar})^2\int_{0}^{t}\int_{0}^{t} V_I(t)V_I(t&#39;)U_Idtdt&#39; \\\\\approx&amp;= I + \frac{1}{i \hbar}\int_{0}^{t} V_Idt\\\\&amp;+ (\frac{1}{i \hbar})^2\int_{0}^{t}\int_{0}^{t} V_I(t)V_I(t&#39;)dtdt&#39;\end{aligned}\]</span><p>令<span class="math inline">\(\left|\psi \right&gt; = \sum_n C_n(t) e^{iE_n t/\hbar} \left|n \right&gt;\)</span>，则<span class="math inline">\(\left|\psi \right&gt;_I = \sum_n C_n(t) \left|n \right&gt;\)</span>,</p><div style="text-align:center"><span class="math inline">\({\left|\psi \right&gt;}_I (t) = U_I \sum_n C_n(t) \left| n \right&gt;\)</span></div><br><div style="text-align:center"><span class="math inline">\(=\sum_n C_n \left| n \right&gt;+\sum_m \sum_n C_n(0) \frac{1}{i\hbar} \left| m \right&gt;\int^t_0\left&lt; m|V_I |n\right&gt;\)</span></div><p>当<span class="math inline">\(C_n(0) = \delta_{nk}\)</span>时，原式化简为：</p><div style="text-align:center"><span class="math inline">\(=\left| k \right&gt; + \sum_m \frac{1}{i\hbar} \int^t_0 \left&lt; m|V_I |k\right&gt; \left| m \right&gt;\)</span></div><br><div style="text-align:center"><span class="math inline">\(=\left| k \right&gt; + \sum_m \frac{1}{i\hbar} \int^t_0 e^{i(E_m-E_k)t/\hbar}\left&lt; m|V_S |k\right&gt; \left| m \right&gt;\)</span></div><p>为了便于计算，转换到了薛定谔表象下，定义<span class="math inline">\(t\)</span>时刻的从k态跃迁到m态的几率为：</p><p><span class="math display">\[P_{k\rightarrow m} = \left| C_m(t)\right| = \left|\frac{1}{i\hbar} \int^t_0 e^{i(E_m-E_k)t/\hbar}\left&lt; m|V_S |k\right&gt; \right|^2\]</span></p><h1 id="常微扰和简谐微扰">常微扰和简谐微扰</h1><p>简谐微扰<span class="math inline">\(V = W(x) e^{iwt} +W^* (x)e^{-iwt}\)</span>，计算跃迁频率表达式：</p><span class="math display">\[\begin{aligned}&amp;\frac{1}{\hbar^2} \left| \int_0^{t} \left&lt;f|V(x) |i\right&gt;e^{i(E_m-E_k)t/\hbar}dt \right|^2\\\\=&amp;   \frac{1}{\hbar^2} | t \left&lt;f|W(x) |i\right&gt; e^{i(w+w_{fi}t)/2}\frac{\sin[(w+w_{fi})t/2]}{(w+w_{fi})t/2}\\\\=&amp; t \left&lt;f|W^*(x) |i\right&gt; e^{i(w-w_{fi}t)/2}\frac{\sin[(w-w_{fi})t/2]}{(w-w_{fi})t/2} |^2\end{aligned}\]</span><p>当<span class="math inline">\(w+w_{fi} \approx 0\)</span>时，第一项起主要影响，再由delta函数的弱极限定义，得到</p><p><span class="math display">\[P \approx \frac{2\pi t}{\hbar}|W_fi|^2 \delta(E_f-E_i-\hbar w)\]</span></p><p>同理<span class="math inline">\(w- w_{fi} \approx 0\)</span>，<span class="math inline">\(P \approx \frac{2\pi t}{\hbar}|W^*_fi|^2 \delta(E_f-E_i+\hbar w)\)</span></p><p>所以共振跃迁的条件为 <span class="math inline">\(\hbar w = E_f -E_i\)</span></p>]]></content>
    
    
    <categories>
      
      <category>量子力学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantum mechanics, 量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>能带理论</title>
    <link href="/2023/01/02/solid5/"/>
    <url>/2023/01/02/solid5/</url>
    
    <content type="html"><![CDATA[<h1 id="基本近似">基本近似</h1><ol type="1"><li><p>波恩奥本海默近似分开原子和电子，原子缓变，电子变化更快</p></li><li><p>电子电子相互作用，用有效势来简化。</p></li><li><p><mark>单电子近似</mark>：将每个电子的运动看成是独立的在一个等效势场中的单电子运动，从而将多电子问题简化为单电子问题。</p></li><li><p>共有化电子：是能带理论的基本概念，固体中的电子不再束缚于个别的原子，而是在整个固体内运动</p></li><li><p>有效势场 <span class="math inline">\(𝑉(𝑟)\)</span> 具有平移周期性：这是晶格具有周期性的结果</p></li></ol><h1 id="bloch-theorem">Bloch theorem</h1><p>在周期性边界条件下，当势能满足周期性时，任意一个本征函数解，存在<span class="math inline">\(k\)</span>使得解满足：</p><span class="math display">\[\begin{aligned}\psi(r+R_n) = e^{ik \cdot R_n}\psi(r)\end{aligned}\]</span><p>其中<span class="math inline">\(k = \frac{l_1}{N_1}b_1+ \frac{l_2}{N_2}b_2+ \frac{l_3}{N_3}b_3\)</span>，<span class="math inline">\(N_i\)</span>为某方向上的重复单元个数，<span class="math inline">\(l_i\)</span>为某整数，令<span class="math inline">\(\psi(r)=e^{(𝑖k \cdot r)} u(r)\)</span>，则得到：<span class="math inline">\(u(r+R_n) = u(r)\)</span>，<span class="math inline">\(\psi(r)\)</span>称为<mark>布洛赫函数</mark></p><p>证明：</p><p>定义：<span class="math inline">\(T\psi(x) = \psi(x+a)\)</span></p><span class="math display">\[\begin{aligned}[T,H]\psi(x) &amp; = T(H(x)\psi(x)) - H(x)(T\psi(x)) \\\\&amp; = H(x+a)\psi(x+a) - H(x)\psi(x+a) \\\\&amp; = H(x+a)\psi(x+a) - H(x+a)\psi(x+a) = 0\end{aligned}\]</span><p>于是可找到一组两个算符的共本态： <span class="math inline">\(\varphi_n\)</span></p><ol type="1"><li><p><span class="math inline">\(T(l a)T(ma)\varphi_n = \lambda_n(la)\lambda_n(ma) \varphi_n = T((l+m)a)\varphi_n = \lambda_n((l+m)a)\varphi_n\)</span></p></li><li><p>由哈密顿量的周期性可得解的周期性 <span class="math inline">\(|\lambda_n(la)^2| = 1\)</span></p></li></ol><p>由以上两个性质可知<span class="math inline">\(\lambda_n^{la} = e^{ila*c}\)</span>，且<span class="math inline">\(c\)</span>为整数，引入周期性条件，一个<span class="math inline">\((N_1,N_2,N_3)\)</span>的箱子，</p><div style="text-align:center">$(r) = (r+N_1*a_1)... _n^{Na} = e^{iNa*c} = 1c =  $</div><p>将<span class="math inline">\(c\)</span>写为<span class="math inline">\(k\)</span>则证毕</p><p>拓展到三维得到 <span class="math inline">\(k\)</span>的取值：<span class="math inline">\(k = \sum_i \frac{l_i}{N_i}\vec{b_i}\)</span>，<span class="math inline">\(l_i= 0,1,2,3..., --N_i/2&lt;l_i&lt;N_i/2\)</span>（为了让每个波函数只对应一个<span class="math inline">\(k\)</span>，限制在了第一布里渊区内取值）</p><p>带入薛定谔方程后，得到：</p><span class="math display">\[\begin{aligned}&amp;[-\frac{\hbar^2}{2m}(\nabla^2+2ik\cdot\nabla-k^2)+V(r)]u_k(r)= Eu_k(r)\\\\&amp;r \in[0,a_1]\times[0,a_2]\times[0,a_3]\end{aligned}\]</span><p>周期性边界条件能够解出参数<span class="math inline">\(n\)</span>，是分立的，随 <span class="math inline">\(k\)</span> 变化准连续。给定一个<span class="math inline">\(k\)</span>，就会有一系列分立的<span class="math inline">\(\\{E_{n}\\}_k\)</span>。</p><p>同样的，给定，可以将同一激发态的能级但属于不同<span class="math inline">\(k\)</span>的能级构成的准连续的集合<span class="math inline">\(\\{E_{k}\\}_n\)</span>称为<mark>能带</mark>，两个能带之间没有交叠，这部分能量间隙称为<mark>禁带</mark>。</p><p><span class="math inline">\(k\)</span>被称为<mark>简约波矢</mark>，标志着相邻晶格间的波函数的相位变化，同时也可以代表一组能量本征态的集合。</p><h1 id="近自由电子近似">近自由电子近似</h1><p>凝胶(jellium)模型：将离子实看成均匀分布的正电荷背景，其目的是忽略晶格（离子实）对电子的作用。</p><h2 id="一种超级唯象但是却被划了重点的能隙推导方法">一种超级唯象但是却被划了重点的能隙推导方法</h2><p>假设一个在第五章中的自由电子平面波<span class="math inline">\(\phi =\frac{1}{L} e^{ikr}\)</span>，<span class="math inline">\(k = \frac{\pi}{a}\)</span>，即波矢在第一布里渊区边界上的电子，其在晶格边界发生反射，<span class="math inline">\(k&#39;=-\frac{\pi}{a}\)</span>，波叠加形成了两种波：</p><span class="math display">\[\begin{aligned}&amp;\phi_{odd} = \sqrt \frac{2}{L} \sin(\frac{\pi}{a}x)\\\\&amp;\phi_{even} = \sqrt \frac{2}{L} \cos(\frac{\pi}{a}x)\end{aligned}\]</span><p>将周期势做展开后得到：</p><p><span class="math inline">\(V(r) = V(0) + V(\frac{2\pi}{a})e^{i\frac{2\pi}{a}r}+V(-\frac{2\pi}{a})e^{-i\frac{2\pi}{a}r}+..\)</span>，高频振荡项忽略，<span class="math inline">\(V(0)\)</span>代表正电荷背景，同时取<span class="math inline">\(v(-G)= V(G)=V_1\)</span>，计算<span class="math inline">\(\left&lt; \phi_{odd}|\Delta V| \phi_{odd}\right&gt;\)</span> ，<span class="math inline">\(\left&lt; \phi_{even}|\Delta V| \phi_{even}\right&gt;\)</span>，最终得到：</p><span class="math display">\[\begin{aligned}\left|\left&lt; \phi_{odd}|\Delta V| \phi_{odd}\right&gt; - \left&lt; \phi_{even}|\Delta V| \phi_{even}\right&gt;\right|  = 2|V_1|\end{aligned}\]</span><p><img src="图片1.png"></p><p>由图可以看出，在正电荷附近，电子密度更高的波函数，对应的能量越低。</p><h5 id="量子力学微扰论推导">量子力学微扰论推导</h5><p>在正电子背景下，<span class="math inline">\(k=\frac{\pi}{a}\)</span>与<span class="math inline">\(k=-\frac{\pi}{a}\)</span> 是一对简并态，加入微扰：</p><span class="math display">\[\begin{aligned}H&#39; = V(\frac{2\pi}{a})e^{i\frac{2\pi}{a}r}+V(-\frac{2\pi}{a})e^{-i\frac{2\pi}{a}r} = 2V&#39; \cos(\frac{2\pi}{a}x)\end{aligned}\]</span><p>计算<span class="math inline">\(H&#39;\)</span>在<span class="math inline">\(\{k\}\)</span>表象下，<span class="math inline">\(k&#39;,k\)</span>子空间的矩阵得到：</p><p><span class="math display">\[\begin{equation}\left( \begin{matrix}    0&amp;      V^{\prime}\\\\    V^{\prime}&amp;     0\\\\\end{matrix} \right)\end{equation}\]</span></p><p>最终解出能量的一级修正以及对应的本征态:</p><span class="math display">\[\begin{aligned}&amp;\phi_{odd} = \frac{1}{\sqrt2} (\phi_k+\phi_{k&#39;}),E_{odd} =E_0+V&#39;\\\\&amp;\phi_{even} = \frac{i}{\sqrt2} (\phi_k-\phi_{k&#39;}),E_{even} =E_0-V&#39;\end{aligned}\]</span><h1 id="紧束缚模型">紧束缚模型</h1><p>认为束缚很强时，电子的波函数在某个原子附近时与单个原子势场下的电子波函数类似，而别的原子在该原子处的势场认为是微扰，单个原子下电子的哈密顿量及本征态写法：</p><span class="math display">\[\begin{aligned}(T+V_l(r-R_l))\varphi(r-R_l) = \epsilon \varphi(r-R_l)\end{aligned}\]</span><p><span class="math inline">\(R_l\)</span>是原子所在的位矢，假设整个晶体微扰的零级波函数写法：</p><p><span class="math display">\[\psi(r)= \sum_l C_l\varphi(r-R_l)\]</span></p><p>根据布洛赫定理得到：</p><span class="math display">\[\begin{aligned}\psi(r)= C \sum_l e^{ikR_l}\varphi(r-R_l)\end{aligned}\]</span><p>进一步归一化波函数，<span class="math inline">\(C = \frac{1}{\sqrt N}\)</span>这种近似被称为LCAO近似，考虑所有原子在<span class="math inline">\(R_l\)</span>处的电子造成的势场对应的哈密顿量为：</p><span class="math display">\[\begin{aligned}H = \sum_i V_i +T = V_l+T+\sum_i&#39;V_i = H_l+\Delta V\end{aligned}\]</span><p>将微扰哈密顿量带入后，得到：</p><span class="math display">\[\begin{aligned}E(k) =&amp; \epsilon- \int\varphi^*(r) \Delta V \varphi(r)dr \\\\&amp;- \sum_i&#39; e^{ikR_i}\int\varphi^*(r) \Delta V \varphi(r-R_i)dr\end{aligned}\]</span>进一步化简，得到：<span class="math display">\[\begin{aligned}E(k) = \epsilon - \sum_i e^{ikR_i}\int\varphi^*(r) \Delta V \varphi(r-R_i)dr\end{aligned}\]</span><h2 id="求解简单立方的s带">求解简单立方的s带</h2><p>扩展到三维以后，<span class="math inline">\(E(\vec k) = \epsilon - \sum_i e^{i\vec k \cdot \vec R_i}\int\varphi^*(\vec r) \Delta V \varphi(\vec r-\vec R_i)d \vec r\)</span>,设<span class="math inline">\(S_0 = \int\varphi^*(\vec r) \Delta V \varphi(\vec r)d\vec r\)</span>，再考虑到S电子态的球对称性，令<span class="math inline">\(S_1 = \int\varphi^*(\vec r) \Delta V \varphi(\vec r-a\vec e_r)d\vec r\)</span>，只考虑最近邻原子的微扰，则<span class="math inline">\(E(\vec k )\)</span>表示为:</p><span class="math display">\[\begin{aligned}E(k) = \epsilon -S_0-2S_1(\cos k_x a+\cos k_y a+\cos k_z a)\end{aligned}\]</span><h1 id="能带的能态密度">能带的能态密度</h1><p>态密度的定义：</p><span class="math display">\[\begin{aligned}g(E) = \frac{dZ}{dE}\end{aligned}\]</span><p>再根据声子模密度表达式的推导，简单易得：</p><span class="math display">\[\begin{aligned}g(E) = \sum_i g_i(k) = \sum_i 2\int_k \frac{N}{V^*}\delta (E-E(k))dk\end{aligned}\]</span><p>2来自于自旋，<span class="math inline">\(V^*\)</span>是布里渊区的大小，N是k点总数或者原子总数。</p><p>第三种表达式由delta函数的性质：</p><p><img src="屏幕截图 2023-01-01 180400.png"></p><span class="math display">\[\begin{aligned}g(E) =\sum_i 2\int_k \frac{N}{V^*}\frac{dS}{\left|\nabla_kE(k)\right|}\end{aligned}\]</span>]]></content>
    
    
    <categories>
      
      <category>固体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solid physics, physics, 固体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自由电子气</title>
    <link href="/2023/01/02/solid4/"/>
    <url>/2023/01/02/solid4/</url>
    
    <content type="html"><![CDATA[<h1 id="section"></h1><h1 id="经典理论">经典理论</h1><p>自由电子近似：电子与离子实之间没有相互作用，电子可以自由地在晶格空间中运动。</p><p>独立电子近似：电子与电子之间没有相互作用，电子可以彼此独立地运动。</p><p>驰豫时间近似：存在驰豫时间，它表示两次碰撞之间的时间间隔；电子通过碰撞与周围环境达到热平衡。</p><p>经典的关于热容和电阻的结论：</p><span class="math display">\[\begin{aligned} &amp;\sigma = \frac{ne^2\tau}{m}\\\\&amp;C_e = \frac{3}{2}n k_B\end{aligned}\]</span><h1 id="量子理论">量子理论</h1><p>凝胶模型：认为势场是平均的, <span class="math inline">\(V_r = Const\)</span>, 极弱束缚的一种描述，<span class="math inline">\(\hat{H} = -\frac{\hbar^2}{2m}\nabla^2\)</span>, 根据箱量子化得到，箱边长为L，体积为V：</p><span class="math display">\[\begin{aligned} &amp;\phi(r) = \frac{1}{\sqrt{V}}e^{ik\cdot r}\\\\&amp;k =(n_x,n_y,n_z) 2\pi/L ~~~n_1,n_2,n_3= 0,\pm1,\pm2...\end{aligned}\]</span><p>则在k空间中，<span class="math inline">\((\frac{2\pi}{L})^3\)</span>的体积内有一个k点，<span class="math inline">\(\rho(k) = \frac{V}{8\pi^3}\)</span>，则能态密度：</p><span class="math display">\[\begin{aligned} &amp;g(E)dE = s\rho(k)\Delta k =s\frac{4\pi k^2dk}{(8\pi^3/V)} \Rightarrow\\\\&amp;g(E) = \frac{V}{2\pi^2} (\frac{2m}{\hbar^2})^{\frac{3}{2}} \sqrt{E}\end{aligned}\]</span><p>s=2 用于记两种自旋</p>巨正则系综的狄拉克分布：<span class="math display">\[\begin{aligned} &amp;f(k) = \frac{1}{e^{(E_k-\mu)/K_BT}+1}\\\\&amp;T \rightarrow 0, E_k&lt;\mu, f(k) = 1, E_k&gt;\mu, f(k) = 0\end{aligned}\]</span><p>由此出发，再结合态密度函数可以直接推导晶体电子热容，兼并压等物理学量。温度为0时的化学势称为费米能级，同时<span class="math inline">\(\frac{\hbar^2 k^2}{2m} =E_F\)</span>，对应的<span class="math inline">\(k_F\)</span>称为费米波矢，费米波矢在k空间形成的圆面被称为费米面。在温度趋近于0时，费米面以下全被占据，以上全空。</p><p>电子热容： <span class="math inline">\(C_e = \frac{\pi^2}{2}\frac{nk_B^2}{E_F}T\)</span></p><h1 id="习题">习题</h1><blockquote><p>1.导出一维二维和三维的自由电子气的能态密度<span class="math inline">\(g(E)\)</span></p></blockquote><p>以二维为例，方面的体积为<span class="math inline">\(S\)</span>，边长为<span class="math inline">\(L\)</span>，则箱量子化后:</p><p><span class="math inline">\(E(k) = \frac{\hbar^2 k^2}{2m} \vec k = (n_1,n_2)\frac{2\pi}{L}\)</span></p><p>则能态密度：</p><p><span class="math inline">\(g(E)dE = s \rho(k) \Delta V_E = s * \frac{S}{4\pi^2} *2\pi k dk\)</span></p><p>则：<span class="math inline">\(g(E) = \frac{dk}{dE}s \frac{S}{4\pi^2} 2\pi k = \frac{S m}{\pi \hbar^2}\)</span></p><blockquote><ol start="2" type="1"><li>证明二维自由电子气的化学势为：<span class="math inline">\(\mu(T) = k_B T ln(e^{\pi \hbar^2n/(mk_BT)}-1)\)</span> n为单位面积上的电子数</li></ol></blockquote><p>由上题可得到<span class="math inline">\(g(E) = \frac{S m}{\pi \hbar^2} = \frac{N m}{n \pi \hbar^2}\)</span>，<span class="math inline">\(N\)</span>为粒子总数</p><p>由费米狄拉克分布：</p><span class="math display">\[\begin{aligned}N = \int_0^\infty \frac{1}{e^{E-\mu}+1} g(E)dE \end{aligned}\]</span><p>将积分化简后即可得到题干</p>]]></content>
    
    
    <categories>
      
      <category>固体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solid physics, physics, 固体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晶格振动</title>
    <link href="/2023/01/02/solid3/"/>
    <url>/2023/01/02/solid3/</url>
    
    <content type="html"><![CDATA[<h1 id="一维单原子链">一维单原子链</h1><p>加入简谐近似（既认为单原子链的相互作用截断到位移的二阶项），以及只考虑最近邻原子的作用后，得运动方程：<span class="math inline">\(M\frac{d^2u_n}{dt^2}= \beta(u_{n+1}+u_{n-1}-2u_n)\)</span></p><p>代入周期性边界条件以及周期性的平移对称不变性，我们得到通解以及色散关系：</p><span class="math display">\[\begin{aligned}u_n = \sum^{}_{l} A_l e^{-iw_lt}e^{inaq}\\\\w^2(q)= \frac{2\beta}{M}(1-cosqa)\end{aligned}\]</span><h3 id="一维双原子晶格振动">一维双原子晶格振动</h3><p>同样的方法解出色散关系</p><p><span class="math display">\[w^2(q) = \frac{\beta}{M_1M_2}[M_1+M_2 \pm \sqrt{M_1^2+M_2^2+2M_1M_2cosqa}]\]</span></p><p><img src="屏幕截图 2022-11-25 175006.png"></p><p>在q趋向于0的时候，<span class="math inline">\(w\)</span>趋向于0的波称为声学支。声学支代表的振动模式相邻原子振动方向同向，另一支称为光学支，相邻原子振动方向相反，同时由于这种振动模式会产生迅速变化的电偶极矩，与光发生相互作用。</p><p>三维的同理，N个原胞，每个原胞s个原子，解出来(没证明)3支声学波，<span class="math inline">\(3s-3\)</span>支光学波</p><h3 id="声子">4. 声子</h3><p>单原子链晶格振动的量子化(简谐近似，只考虑最近邻原子间的相互作用)：</p><div style="text-align:center"><span class="math inline">\(H = T+U = \frac{1}{2} M \sum^{}_{n}\dot u_n^2 + \frac{1}{2} \beta \sum^{}_{n}(u_{n-1}-u_n)^2\)</span></div><p>欲对<span class="math inline">\(H\)</span>的形式进行变化方便看出具体形式，做变量代换：</p><p><span class="math inline">\(u_n(t) = \sum^{}_{l} A_l(t) e^{-iw_lt}e^{inaq_l}\)</span>，其中<span class="math inline">\(q_l=\frac{2\pi l}{Na},-\frac{N}{2}\leq l&lt;\frac{N}{2}\)</span></p><p>令 <span class="math inline">\(Q_l(t) = (NM)^{\frac{1}{2}}A_l e^{-iw_l t}\)</span> 则</p><span class="math display">\[\begin{aligned}u_n = (NM)^{-\frac{1}{2}}\sum^{}_{l}Q_l e^{inaq_l}\\\\Q_l = (\frac{M}{N})^{1/2}\sum_n u_ne^{-inaq}\end{aligned}\]</span><blockquote><p>正交性条件：<span class="math inline">\(\frac{1}{N} \sum_n e^{ina(q_l-q_{l&#39;})} = \delta _{ll&#39;}\)</span> (易证)</p></blockquote><blockquote><p>由<span class="math inline">\(u_n\)</span>为实数可推得 <span class="math inline">\(Q_l* = Q_{-l}\)</span></p></blockquote><span class="math display">\[\begin{aligned}T &amp;= \frac{M}{2} \sum^N_n \dot u_n^2\\\\ &amp;= \frac{1}{2N} \sum^N_{n=0} \sum_{l&#39;}\sum_l \dot Q_l \dot Q_{l&#39;}e^{ina(q_l+q_{l&#39;})}\\\\ &amp;= \frac{1}{2} \sum_l \sum_{l&#39;} \dot Q_l \dot Q_{l&#39;} \delta_{ll&#39;}\\\\ &amp;= \frac{1}{2} \sum_l  \dot Q_l ^2\end{aligned}\]</span><p>第二行由定义，第三行由正交性条件</p><div style="text-align:center"><span class="math inline">\(V= \frac{1}{2} \beta \sum^{N}_{n=0}(u_{n-1}-u_n)^2\)</span></div><br><div style="text-align:center"><span class="math inline">\(=\frac{1}{2} \beta \sum^{N}_{n=0}u_{n-1}^2 - 2u_{n-1}u_n + u_n^2\)</span></div><br><div style="text-align:center"><span class="math inline">\(= \beta \sum^{N}_{n=0}u_{n}^2 - u_{n-1}u_n\)</span></div><br><div style="text-align:center"><span class="math inline">\(=\frac{1}{NM}\beta \sum_n\sum_{l}\sum_{l&#39;} Q_lQ_{l&#39;} e^{inaq_l}e^{inaq_{l&#39;}}(1 - e^{-iaq_l})\)</span></div><br><div style="text-align:center"><span class="math inline">\(= \frac{\beta}{M} \sum_{l} Q_lQ_{l}*(1 - e^{-iaq_l})\)</span></div><br><div style="text-align:center"><span class="math inline">\(= \frac{(1-cos(aq))\beta}{2M} \sum_{l} Q_lQ_{l}^*\)</span></div><br><div style="text-align:center"><span class="math inline">\(= w_l^2 Q_lQ_{l}^*\)</span></div><p>第三个等号来源于周期性边界条件，第六个等号来源于<span class="math inline">\(V\)</span>是实数，所以可以取实部，第七个等号来源于一维振子解的色散关系，可以理解为用这个定义了<span class="math inline">\(w_l\)</span>，显然是一个谐振子哈密顿量，后面可以把对应的能量子定义为声子。</p><h4 id="声子性质">声子性质</h4><p>从基态<span class="math inline">\(n_l = 0\)</span> 到激发态<span class="math inline">\(n_l (≠ 0)\)</span> 的能量差为<span class="math inline">\(n_l ћω_l\)</span>，这一过程可以看成是产生了<span class="math inline">\(n_l\)</span>个频率<span class="math inline">\(ћω_l\)</span>的声子，每个声子的能量为<span class="math inline">\(ћω_l\)</span>。（元激发）波矢q的方向代表格波的传播方向，也代表声子的运动方向，<span class="math inline">\(\hbar q\)</span> 称为声子的准动量。</p><h3 id="离子晶体的红外光学性质">离子晶体的红外光学性质</h3><h4 id="光学模">光学模</h4><p>光学模是正负离子相对振动的一种振动模式，如图所示：</p><p><img src="3E0B5AE836EBB34B602A8B51A62691D5.png"></p><p><mark>纵波由于离子移动形成了指向回复方向的极化电场，所以振动变快，频率高于不会形成极化电场的横波</mark>。同时由于电磁波为横波，只有横光学模能够与电磁波发生耦合。</p><h4 id="黄昆方程">黄昆方程</h4><span class="math display">\[\begin{aligned}\frac{d^2W}{dt^2} = b_{11} W +b_{12}E\\\\ p = b_{12}W +b_{22}E\end{aligned}\]</span><p><span class="math inline">\(W = (\mu n)^{-\frac{1}{2}}(u_+ - u_-)\)</span>，<span class="math inline">\(n\)</span> 为单位体积内的原胞数，<span class="math inline">\(\mu\)</span> 是折合质量，<span class="math inline">\(u_+(u_-)\)</span>是正(负)离子的振动位移，<span class="math inline">\(b_{ij}\)</span>为待定系数。</p><h4 id="lst关系">LST关系</h4><span class="math display">\[\begin{aligned}b_{11}&amp;= -w_{TO}^2\\\\ \epsilon(0) &amp;= \frac{w^2_{LO}}{w^2_{TO}} \epsilon(\infty)\\\\ w_{LO}^2 &amp;= w_{TO}^2 + \frac{b^2_{12}}{\epsilon_0+b_{22}}\\\\ \epsilon(\infty) &amp;= 1+ \frac{b_{22}}{\epsilon_0}\end{aligned}\]</span><h4 id="晶格热容">晶格热容</h4><p>略</p><h3 id="习题">习题</h3><blockquote><p>在一维单原子晶格中，若考虑每一原子与其余原子都有相互作用，在简谐近似下求格波的色散关系</p></blockquote><span class="math inline">\(ij\)</span>原子的相互距离：<span class="math inline">\(x_{ij} = x_i -x_j\)</span> , <span class="math inline">\(x_i = x_i^0 +u_i\)</span> ,<span class="math inline">\(u_i\)</span>为振幅，<span class="math inline">\(x_i^0\)</span>为平衡位置<div style="text-align:center"><span class="math inline">\(U = \frac{1}{2} \sum^N_{i,j}\phi(x_{ij}^0) + \frac{\partial \phi}{\partial x_{ij}}|_{x_{ij}^0}u_{ij}+\frac{1}{2}\frac{\partial^2 \phi}{\partial x_{ij}^2}|_{x_{ij}^0} u_{ij}^2\)</span></div><div style="text-align:center"><span class="math inline">\(= \frac{1}{4}\frac{\partial^2 \phi}{\partial x_{ij}^2}|_{x_{ij}^0} u_{ij}^2\)</span></div><p>去掉了常数，以及在稳定状态下一阶导为0。</p><div style="text-align:center"><span class="math inline">\(M \ddot u_{n} = - \frac{\partial U}{\partial u_n} = -\sum_{j} \beta_{nj} (u_n-u_j)\)</span></div><br><div style="text-align:center"><span class="math inline">\(M \ddot u_{n} = - \sum_{j=0}^{\frac{N}{2}} \beta_{n,{n+j}} (u_{n+j}-2u_{n}+u_{n-j})\)</span></div><p>假设解的形式为：<span class="math inline">\(u_n = e^{iwt-inaq}\)</span> 代入得： <span class="math inline">\(w^2 = \frac{2}{M} \sum_j^{N/2} (1- cos(jaq))\)</span></p><blockquote><p>设有一维双原子晶格，两种原子的质量相等，最近邻原子的力常量交错等于<span class="math inline">\(\beta_1\)</span>和<span class="math inline">\(\beta_2\)</span>，求色散关系</p></blockquote><span class="math display">\[\begin{aligned}M \ddot u_n = \beta_1(v_{n+1} -u_n) + \beta_2 (v_{n}-u_{n})\\\\  M \ddot v_n = \beta_2(u_{n} -v_n) + \beta_1 (u_{n-1}-v_{n})\end{aligned}\]</span><p><span class="math inline">\(v_n, u_n\)</span>分别代表两种不同原子的振动表达式。将试探解 <span class="math inline">\(v_n = Ae^{iwt-inaq}, u_n =B e^{iwt-inaq}\)</span>，带入得：</p><span class="math display">\[\begin{aligned}(-Mw^2 +\beta_1+\beta_2) B - (\beta_1e^{-iaq}+\beta_2)A = 0\\\\(\beta_2+\beta_1e^{iaq})B - (\rho_2+\rho_1- Mw^2)A = 0\end{aligned}\]</span><p>由系数行列式等于0得到：<span class="math inline">\(w^2 = \frac{\beta_1+\beta_2 \pm \sqrt{2\beta_1\beta_2cos(aq)+\beta_1^2+\beta^2}}{M}\)</span></p><blockquote><ol start="3" type="1"><li>求一维单原子晶格的格波的模密度以及低温热容：</li></ol></blockquote>模密度的表达式：<span class="math display">\[\begin{aligned}g(w) &amp;= \sum_i g_i(w) = \sum_i \frac{dN_i}{dw} \\\\&amp; = \sum_i\frac{d \sum_k\Omega(w-w_i(k))}{dw}\\\\ &amp;= \sum_i \sum_k\delta(w-w_i(k))\\\\ &amp;=\sum_i \frac{N}{V^*} \int \delta(w-w_i(k))dk\end{aligned}\]</span><p><span class="math inline">\(i\)</span>代表不同的支，第三个等式 <span class="math inline">\(\Omega\)</span> 代表阶跃函数，代表对<span class="math inline">\(k\)</span>空间的每个波矢所对应的频率计数，比<span class="math inline">\(w\)</span>低的记1，最后一个等号对k空间近似连续化，<span class="math inline">\(V^*\)</span>代表<span class="math inline">\(k\)</span>空间大小，<span class="math inline">\(N\)</span>代表k点的个数，由<span class="math inline">\(w^2 = \frac{2\beta}{M}(1-cos(ka))\)</span> 得到 <span class="math inline">\(2wdw = \frac{2\beta}{M}a sin(ka)dk\)</span></p><p>于是模密度表达式：</p><span class="math display">\[\begin{aligned}&amp;\sum_i \frac{N}{V^*} \int \delta(w-w_i(k))dk\\\\&amp; = \frac{LN}{2\pi} \int \delta(w-w(k))\frac{w(k)dw(k)}{\frac{\beta}{M}a\sin(\arccos(1-\frac{Mw(k)^2}{2\beta}))}\\\\&amp; =  \frac{LN}{2\pi}\frac{w}{\frac{\beta}{M}a\sin(\arccos(1-\frac{Mw^2}{2\beta}))}\end{aligned}\]</span><p>低温热容:</p>系统的配分函数：<span class="math display">\[\begin{aligned}Z &amp;= \Pi_{w_i} \sum_n e^{-\beta E_n}\\\\&amp;= \Pi_{w_i} \sum_n e^{-\beta (\hbar w_i(1/2+n))}\\\\&amp;= \Pi_{w_i} (2\sinh(\beta\hbar w_i/2))^{-1}\end{aligned}\]</span><p>将每个振动模视作独立的正则系综，同时相互之间无相互作用，热容表达式</p><p><span class="math display">\[C_v = \frac{1}{k_BT^2}\frac{\partial^2 lnZ}{\partial \beta^2}\]</span></p><p>则：</p><span class="math display">\[\begin{aligned}\ln Z =&amp; -\sum_w ~\ln(2 \sinh(\beta\hbar w_i/2))\\\\ =&amp; -\frac{1}{N}\int_0^{w_{max}} g(w)\ln(2 \sinh(\beta\hbar w/2)) dw\\\\ &amp;\frac{\partial^2 lnZ}{\partial \beta^2} = \frac{1}{N} \int_0^{w_{max}} g(w)(\frac{\hbar w}{2})^2\frac{1}{\cosh(\beta\hbar w/2)\tanh^2(\beta\hbar w/2)} dw\end{aligned}\]</span><p><span class="math inline">\(N\)</span>为总波模数，由于代求低温热容，低温下 <span class="math inline">\(w\)</span> 小的起主要贡献，大的由<span class="math inline">\(\frac{\partial^2 lnZ}{\partial \beta^2}\)</span> 表达式可看出，趋近于0，所以可以近似将 <span class="math inline">\(g(w)\)</span> 在 <span class="math inline">\(w\ll 1\)</span> 时的表达式替换到积分中，则：</p><span class="math display">\[\begin{aligned}\sin(\arccos(1-\frac{Mw(k)^2}{2\beta_u}))= \sqrt{1-(1-\frac{Mw^2}{2\beta_u})^2} \approx \sqrt{M/\beta_u}w\\\\g(w) = \frac{NL}{2\pi}\frac{w}{\frac{\beta_u}{M}a\sin(\arccos(1-\frac{Mw^2}{2\beta}))} = \frac{NL}{2\pi a}\sqrt\frac{M}{\beta_u}\end{aligned}\]</span><p>为了区别，<span class="math inline">\(\beta_u\)</span>表示晶格振动中的力常量。</p><p>则低温热容：</p><span class="math display">\[\begin{aligned}C_v &amp;= \frac{1}{k_BT^2}\frac{\partial^2 lnZ}{\partial \beta^2}\\\\&amp;= \frac{1}{k_BT^2}\frac{1}{N} \int_0^{w_{max}} g(w)(\frac{\hbar w}{2})^2\frac{1}{\cosh^2(\beta\hbar w/2)\tanh^2(\beta\hbar w/2)} dw\\\\&amp;\approx\frac{L}{2\pi a k_BT^2 }\sqrt\frac{M}{\beta_u}  \int_0^{w_{max}} (\frac{\hbar w}{2})^2\frac{1}{\sinh^2(\beta\hbar w/2)} dw\\\\&amp;\approx\frac{L}{2\pi a k_BT^2 }\sqrt\frac{M}{\beta_u}  \int_0^{\infty} (\frac{\hbar w}{2})^2\frac{1}{\sinh^2(\beta\hbar w/2)} dw\\\\&amp;=\frac{L}{2\pi a k_BT^2 }\sqrt\frac{M}{\beta_u}\int_0^{\infty} \frac{2}{\beta^3\hbar}x^2\frac{1}{\sinh^2 x} dx\\\\&amp; = \frac{L}{2\pi a k_BT^2 }\sqrt\frac{M}{\beta_u}\frac{2}{\beta^3\hbar} I\\\\&amp; = \frac{K_B^2L}{a\pi \hbar}\sqrt\frac{M}{\beta_u} I T\end{aligned}\]</span><p><span class="math inline">\(I\)</span>代表积分值，结果与<span class="math inline">\(T\)</span>呈一次方关系</p><blockquote><p>运用德拜模型计算低温下的晶体热容</p></blockquote><p><mark>德拜假设低温下起主要作用的都是声学模，其色散关系可以近似为<span class="math inline">\(w=cq\)</span></mark></p><p>则频率密度<span class="math inline">\(g(w) = \frac{1}{V^*} \int \delta(w-w(q))dq =\frac{l}{\pi c}\)</span></p><p>则热容的表达式：</p><span class="math display">\[\begin{aligned}C_v &amp;= \frac{\partial\sum_w  E_w}{\partial T} = \frac{\sum_w\partial (\frac{1}{2}\hbar w+\bar n\hbar w)}{\partial T} \\\\&amp;= \frac{\partial\sum_w \bar n\hbar w}{\partial T} \\\\&amp;= \frac{\partial}{\partial T}\int \frac{1}{N}\frac{g(w)dw}{e^{\frac{1}{2}\hbar w}-1}\frac{1}{2}\hbar w\\\\&amp;=\frac{l}{\pi c} \frac{k_bT^2}{\hbar}\int_0^\infty\frac{x^2e^x}{(e^{x}-1)^2}dx\end{aligned}\]</span><blockquote><p>证明一维单原子晶格中，激发出一个<span class="math inline">\(\hbar q_0\)</span>的声子后动量不变。</p></blockquote>不妨令初始状态初动量为0，激发一个声子后，整体动量：<span class="math display">\[\begin{aligned}p =&amp; \sum_n m \dot u_n  \\\\ =&amp;\sum_n m \sum_q \dot e^{iwt-inaq} = iw \sum_n m e^{iwt-inaq_0} \\\\=&amp; iwm e^{iwt}\sum_n e^{-inaq} = 0\end{aligned}\]</span><p>最后一个等式来源于等比数列求和</p>]]></content>
    
    
    <categories>
      
      <category>固体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solid physics, physics, 固体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晶体结合能</title>
    <link href="/2023/01/02/solid2/"/>
    <url>/2023/01/02/solid2/</url>
    
    <content type="html"><![CDATA[<h3 id="晶体的结合能">晶体的结合能：</h3><p>定义为<span class="math inline">\(E_c = E_{N,free} - E_0\)</span>，第一项所有原子自由状态下的总能量，第二项结合之后晶体的能量。</p><p>通常取<span class="math inline">\(E_{N,free} = 0\)</span>, 忽略掉一些能量之后，可以认为晶体的总能量<span class="math inline">\(E_0\)</span>就等于原子间总的相互作用能，也就是晶体的内能。</p><p>内能表达式<span class="math inline">\(U = \frac{1}{2}N\sum_i{\phi(r_{ij})} =\frac{1}{2}N\phi\)</span>，<span class="math inline">\(\phi\)</span>代表别的原子在第<span class="math inline">\(j\)</span>个原子处造成的势。</p><h3 id="分子晶体的结合能">分子晶体的结合能</h3><p>假设相互作用势可以用<span class="math inline">\(\phi(r_{ij}) = 4\epsilon[(\frac{\sigma}{r_{ij}})^{12}- (\frac{\sigma}{r_{ij}})^6]\)</span> 这种势能表达形式也称为<mark>Lennard-Jones势</mark>。</p><p>计算出对应的晶体内能为：</p><span class="math display">\[\begin{aligned}U(r) = 2N \epsilon [A_{12}(\frac{\sigma}r)^{12}+A_{6}(\frac{\sigma}r)^{6}]\\\\A_{12} = \sum^n_j \frac{1}{a_j^{12}}\enspace A_{6} = \sum^n_j \frac{1}{a_j^{6}}\end{aligned}\]</span><p><span class="math inline">\(r\)</span>为最近邻原子的距离，<span class="math inline">\(a_j\)</span>取决于晶体结构，使得<span class="math inline">\(r_{ij} = a_j r\)</span></p><h3 id="离子晶体的结合能">离子晶体的结合能</h3><p>假设相互作用势可以用 <span class="math inline">\(\phi(r_{ij}) = \pm \frac{e^2}{4\pi\epsilon_0 }r_{ij} + \frac{b}{r_{ij}^n}\)</span>,这种势能表达形式也称为<mark>Born-Mayer势</mark></p><p>计算出对应的晶体内能为：</p><span class="math display">\[\begin{aligned} U(r) = -\frac{N}{2} (\frac{\alpha e^2}{4\pi\epsilon_0r}- \frac{B}{r^n})\\\\B = \sum^N_j \frac{b}{a_j^{n}}\enspace \alpha = -\sum^N_j \pm\frac{1}{a_j}\end{aligned}\]</span><p><span class="math inline">\(r\)</span>为最近邻原子的距离，<span class="math inline">\(a_j\)</span>取决于晶体结构，使得<span class="math inline">\(r_{ij} = a_j r\)</span>，<span class="math inline">\(\alpha\)</span>叫<mark>Madelung常量</mark>(异号原子取正，同号原子取负)，b, n 用实验测出</p><h3 id="习题">习题</h3><blockquote><ol type="1"><li>证明1维NaCl晶格的Madelung常量等于 2ln2</li></ol></blockquote><p>​ 结构示意图：... --2------1------0------1-------2----... hhh</p><p>左右对称，以0号原子出发来计算，所以不妨将求和取为：</p><span class="math display">\[\begin{aligned} \alpha &amp;= 2\sum^{N/2}_{i=1}a_i \\\\&amp;= 2(1-1/2+1/3-1/4 ...) = 2ln(2)\end{aligned}\]</span><p>第二行是因为：<span class="math inline">\(ln(x+1)= x-x^2/2+x^3/3...\)</span></p><blockquote><p>若离子间的排斥势用 <span class="math inline">\(\lambda e^{-r_{ij}/\rho}\)</span>表示，并且只考虑最近邻相互作用，求出结合能表达式，并讨论参量<span class="math inline">\(\lambda,\rho\)</span>如何确定。</p></blockquote><p>结合能的表达式应该写为：</p><span class="math display">\[\begin{aligned} U = \sum^N_{j} \pm \frac{e^2}{4\pi\epsilon_0 }r_{ij} + \sum_{closest ~ions} \lambda e^{-r_{ij}/\rho} \\\\ =  -\frac{N}{2} \frac{\alpha e^2}{4\pi\epsilon_0r} - Z \lambda e^{-r/\rho}\end{aligned}\]</span><p><span class="math inline">\(\alpha = -\sum^N_j \pm\frac{1}{a_j}\)</span>, <span class="math inline">\(r\)</span> 为最近邻原子距离，Z为最近邻原子个数，是一个结构常数，<span class="math inline">\(\lambda\)</span>和<span class="math inline">\(\rho\)</span>由实验测得。</p><blockquote><p>如果NaCl中的离子晶体电荷量增加一倍，讨论<span class="math inline">\(U\)</span>和<span class="math inline">\(r\)</span>的变化</p></blockquote><span class="math display">\[\begin{aligned} U(r) = -\frac{N}{2} (\frac{\alpha e^2}{4\pi\epsilon_0r}- \frac{B}{r^n})\\\\B = \sum^N_j \frac{b}{a_j^{n}}\enspace \alpha = -\sum^N_j \pm\frac{1}{a_j}\end{aligned}\]</span><p>首先，由<span class="math inline">\(r_0\)</span>是<span class="math inline">\(\frac{\partial U}{\partial r} = 0\)</span>的点得到： <span class="math inline">\(r_0^{n-1} = \frac{nB4\pi\epsilon_0}{\alpha e^2}\)</span>，进而得到：<span class="math inline">\(U(r_0) = -\frac{N\alpha e^2}{8\pi \epsilon_0}(1-\frac{1}{n})\frac{1}{r_0}\)</span></p><p>当<span class="math inline">\(e\)</span>扩大一倍后，<span class="math inline">\(r_0\)</span>缩小为原长度的<span class="math inline">\((1/4)^{1/n-1}\)</span>，U变化为原能量的<span class="math inline">\(4^{n/n-1}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>固体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solid physics, physics, 固体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WKB近似</title>
    <link href="/2022/12/23/quantum2/"/>
    <url>/2022/12/23/quantum2/</url>
    
    <content type="html"><![CDATA[<h1 id="经典允许区与经典禁区的解">经典允许区与经典禁区的解</h1><p>假设经典允许区解的形式为<span class="math inline">\(\varphi(x) = A(x) e^{is(x)/\hbar}\)</span>，<span class="math inline">\(A\)</span>随<span class="math inline">\(x\)</span>是缓变的，带入薛定谔方程中得到：</p><p><span class="math display">\[i\hbar s&#39;&#39;(x) -[s&#39;(x)]^2 = 2m[V(x)-E]\]</span></p><p>将s(x)以<span class="math inline">\(\hbar\)</span>的阶数展开：<span class="math inline">\(s(x)=s_0(x)+ \hbar s_1(x)...\)</span>带入方程解出一阶近似：</p><p><span class="math display">\[\varphi(x) \approx \frac{A&#39;}{\sqrt{p(x)}}e^{\pm i\int^x p(x&#39;)dx&#39;/\hbar}\]</span></p><p>其中<span class="math inline">\(p(x)= \sqrt{2m(E-V(x))}\)</span></p><p>同理经典禁区的解：</p><p><span class="math display">\[\varphi(x) \approx \frac{B&#39;}{\sqrt{q(x)}}e^{\pm \int^x q(x&#39;)dx&#39;/\hbar}\]</span></p><p>其中<span class="math inline">\(q(x)= \sqrt{2m(V(x)-E)}\)</span></p><h1 id="连接区的公式">连接区的公式</h1><p>在经典禁区与经典允许区附近WKB近似无效，所以采用直接求解的方法，同时在<span class="math inline">\(x \rightarrow x_0+\Delta,x\rightarrow x_0-\Delta\)</span>时，与wkb近似出来的解趋于一致。</p><p><img src="1.jpg" width="200"></p><p>$V(x) V(x_0) + V'(x_0)x = E + V'(x_0)x $，用线性势近似后，得到airy方程：</p><p><span class="math display">\[\varphi&#39;&#39;(\xi) = \xi \varphi(\xi) \]</span></p><p>其中<span class="math inline">\(\xi= (\frac{2mg}{\hbar^2})^{\frac{1}{3}}(x-x_0)\)</span>，其解可参考<a href="https://zhuanlan.zhihu.com/p/459562140">网页</a>，其通解为<span class="math inline">\(\varphi(\xi) = aAi(\xi)+bBi(\xi)\)</span>，根据其渐进行为：可以得到<span class="math inline">\(b=0\)</span>，同时<span class="math inline">\(a=\frac{2\sqrt \pi C}{(\frac{2mg}{\hbar^2})^{\frac{1}{6}}}\)</span>，<span class="math inline">\(C\)</span>为允许区的常数</p><h1 id="全局的解">全局的解</h1><p><img src="2.png"></p>]]></content>
    
    
    <categories>
      
      <category>量子力学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantum mechanics, 量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.微分形式</title>
    <link href="/2022/12/14/gr6/"/>
    <url>/2022/12/14/gr6/</url>
    
    <content type="html"><![CDATA[<h1 id="定义">定义</h1><p>假设<span class="math inline">\((0,l)\)</span>型张量满足$w_{a_1a_2...a_l} =w_{[a_1a_2...a_l]} <span class="math inline">\(，则称该张量为\)</span>l$次形式。</p><p>由抽象指标和具体指标可相互代换容易得到在某个基底下的展开系数：</p><p><span class="math display">\[w_{\mu_1\mu_2...\mu_l} =w_{[\mu_1\mu_2,...\mu_l]} \]</span></p><p>于是简单得到任何坐标系下，<span class="math inline">\(w_{221}\)</span>等这种分量角标重复的都等于0，只可能存在<span class="math inline">\(w_{231}\)</span>等这种分量。</p><p>容易验证<span class="math inline">\(l\)</span>形式的张量满足<span class="math inline">\((0,l)\)</span>型张量线性子空间的定义，记作<span class="math inline">\(\varLambda(l)\)</span>。</p><h1 id="楔形积">楔形积：</h1><p><span class="math inline">\(w\)</span>是<span class="math inline">\(l\)</span>形式，<span class="math inline">\(w&#39;\)</span>是<span class="math inline">\(m\)</span>形式，则定义他两的楔形积<span class="math inline">\(w \wedge w&#39;\)</span>:</p><div style="text-align:center"><span class="math inline">\(w \land w&#39;_{a_{1}a_{2}...a_{l+m}} = \frac{(l+m)!}{l!m!} w_{[a_{1}a_{2}..a_{l}}w&#39;_{a_{l+1}a_{l+2}...a_{l+m}]}\)</span></div><p>显然<span class="math inline">\(w \land w&#39;\)</span>是(l+m)型反称张量。</p><h1 id="varlambdal的维数"><span class="math inline">\(\varLambda(l)\)</span>的维数：</h1><p>假设流形的维度为<span class="math inline">\(n\)</span>,则<span class="math inline">\(dim \varLambda(l) = \frac{n!}{l!(n-l)!}\)</span>,<span class="math inline">\(l&gt;n\)</span>的情况无意义或者等于0。</p><p>证明：</p><p>借助基底场证明，<span class="math inline">\(\forall w_{a_1a_2...a_l} \in \varLambda(l) \subset T(0,l)\)</span>，可以写为<span class="math inline">\(w_{a_1a_2...a_l}=\sum_{i_1i_2...i_l} w_{i_1i_2...i_l} e_{i_1}e_{i_2}...e_{i_l}\)</span>，由前显然有<span class="math inline">\(w_{nn}\)</span>等于0，再由<span class="math inline">\(w_{a_1a_2...a_l} = w_{[a_1a_2...a_l]} = \delta{(\pi)} w_{a_{\pi(0)}a_{\pi(1)}...a_{\pi(l)}}\)</span>，<span class="math inline">\(\delta{(\pi)}\)</span>为逆序数，有<span class="math inline">\(w_{i_1i_2...i_l} = \delta{(\pi)} w_{i_{\pi(0)}i_{\pi(1)}...i_{\pi(l)}}\)</span>,为了便于说明，假定<span class="math inline">\(n =5,l=3\)</span>，将分量以展开系数的组合分类，比如分量<span class="math inline">\(w_{134} e_{1}e_{3}e_{4},w_{341} e_{3}e_{4}e_{1}\)</span>都属于<span class="math inline">\((1,3,4)\)</span>这个分类，由楔形积定义，</p><span class="math display">\[\begin{aligned}e_1\wedge e_3 \wedge e_4 &amp;= 3! e_{[1}e_3e_{4]}\\\\ &amp;= 3! \frac{1}{3!}(\sum_\pi e_{\pi(1)}e_{\pi(2)}e_{\pi(3)})    \\\\ &amp;= \sum_\pi e_{\pi(1)}e_{\pi(2)}e_{\pi(3)}\end{aligned}\]</span><p><span class="math inline">\(\pi(i)\pi(2)\pi(3)\)</span>是<span class="math inline">\((1,3,4)\)</span>的任意一种排序，最终得到:<span class="math inline">\(w_{134}e_1\wedge e_3 \wedge e_4\)</span>就是<span class="math inline">\((1,3,4)\)</span>所有元素求和的表达式，推广得到：</p><div style="text-align:center"><span class="math inline">\(w_{a_1a_2...a_l}=\sum_{i_1,i_2,...i_l} w_{i_1i_2...i_l} e_{i_1}\wedge e_{i_2}\wedge ...\wedge e_{i_l}\)</span></div><p><span class="math inline">\(i_1,..i_l\)</span>是从<span class="math inline">\(1,2,..n\)</span>中选出来的<span class="math inline">\(l\)</span>个无顺序的数，所以<span class="math inline">\(dim\varLambda(l) = \frac{n!}{l!(n-l)!}\)</span>，并且<span class="math inline">\(e_{i_1}\wedge e_{i_2}\wedge ...\wedge e_{i_l}, j&gt; i\)</span>是<span class="math inline">\(\varLambda(l)的基\)</span></p><h1 id="外微分算符">外微分算符</h1><p>假设<span class="math inline">\(w_{a_1a_2...a_l}\)</span>是<span class="math inline">\(l\)</span>形式场，则定义<span class="math inline">\(dw_{a_1a_2...a_l}\)</span>:</p><p><span class="math display">\[dw_{ba_1a_2...a_l}= (l+1) \nabla_{[b}w_{a_1a_2...a_l]}\]</span></p><p>其中<span class="math inline">\(\nabla\)</span>为任意导数算符，因为克氏符下标对称可交换，所以得到该定义对于任意导数算符得到的结果相同。</p><h2 id="theorem-1">theorem 1:</h2><div style="text-align:center"><span class="math inline">\(d w_{ba_1a_2...a_l} = \sum_C d(w_{\mu_1\mu_2...\mu_l})_b\wedge (d x^{\mu_1})_{a_l} \wedge (d x^{\mu_2})_{a_2} ...\wedge (d x^{\mu_l})_{a_l}\)</span></div><p>证明：</p><p>由定义有<span class="math inline">\(d w_{ba_1a_2...a_l} = (l+1)\partial_{[b}w_{a_1a_2...a_l]} = 1\)</span></p>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.超曲面</title>
    <link href="/2022/12/09/gr5/"/>
    <url>/2022/12/09/gr5/</url>
    
    <content type="html"><![CDATA[<h1 id="定义">定义</h1><p>当一个流形<span class="math inline">\(S\)</span>，通过一个单射的无穷阶可导的映射<span class="math inline">\(\phi\)</span>映射到流形<span class="math inline">\(M\)</span>上，<span class="math inline">\(dimS \le dim M\)</span>，且该映射<span class="math inline">\(\phi\)</span>的推前映射非退化（<span class="math inline">\(\phi_* v^a = 0\Rightarrow v^a = 0\)</span>）,则称<span class="math inline">\(\phi[S]\)</span>是一个嵌入子流形，如果<span class="math inline">\(dim(S) = dim(M)-1\)</span>，则称为超曲面。</p><h1 id="超曲面上的矢量">超曲面上的矢量：</h1><h2 id="theorem1">theorem1:</h2><p>超曲面某点p上的所有经过该点并且所有像点都在超曲面上的曲线的切矢构成了一个线性空间。</p><p>证明：</p><p><span class="math inline">\(\phi[S]\)</span>是可以定义其上的拓扑为诱导拓扑(见选读正则嵌入，默认是正则嵌入)，由于<span class="math inline">\(\phi\)</span>是一个<span class="math inline">\(C^\infty\)</span>的单射，可以认为它是<span class="math inline">\(S\)</span>和<span class="math inline">\(\phi[S]\)</span>上的双射，由<span class="math inline">\(S\)</span>上的图册<span class="math inline">\(O_i\)</span>及对应的坐标映射<span class="math inline">\(\phi_i\)</span>，可得到<span class="math inline">\(\phi[S]\)</span>上存在对应的图册<span class="math inline">\(\phi[S]\)</span>以及对应的映射<span class="math inline">\(\phi_i \cdot \phi^{-1}\)</span>，所以<span class="math inline">\(\phi[S]\)</span>是个微分流形并且与<span class="math inline">\(S\)</span>微分同胚，则该流形的切空间<span class="math inline">\(W\)</span>构成矢量空间。</p><h2 id="法余矢">法余矢</h2><p>超曲面<span class="math inline">\(\phi[S]\)</span>上的一点<span class="math inline">\(p\)</span>，作为<span class="math inline">\(M\)</span>的一点，有对应的切空间<span class="math inline">\(W\)</span>，同时作为<span class="math inline">\(\phi[S]\)</span>的一点，也有自己对应的切空间<span class="math inline">\(W&#39;\)</span>，由<span class="math inline">\(\phi_*\)</span>将<span class="math inline">\(S\)</span>上的<span class="math inline">\(\phi^{-1}p\)</span>的切矢量映射到<span class="math inline">\(p\)</span>上构成了一个线性空间是<span class="math inline">\(W\)</span>的子空间，如果是限制<span class="math inline">\(\phi\)</span>映射到<span class="math inline">\(\phi[S]\)</span>上的话，则被限制的<span class="math inline">\(\phi_*\)</span>的值域为<span class="math inline">\(W&#39;\)</span>，<span class="math inline">\(\phi_*\)</span>的值域和<span class="math inline">\(W&#39;\)</span>有很自然的同构关系，之后将用<span class="math inline">\(W&#39;\)</span>来指代<span class="math inline">\(\phi_*\)</span>的值域，<mark>所以由线性代数可以在M上找出<span class="math inline">\(v_n\)</span>使得成为<span class="math inline">\(W\)</span>上的基且与<span class="math inline">\(W&#39;\)</span>线性无关，则将这个矢量对应的对偶向量称为法余矢</mark>。显然法余矢作用于<span class="math inline">\(w^a \in W&#39;\)</span>为0。</p><h2 id="theorem2">theorem2:</h2><p>假设标量场在超曲面上取值为常数，且在q点处<span class="math inline">\(\nabla_a f \ne 0\)</span>, 则<span class="math inline">\(\nabla_a f\)</span>是<span class="math inline">\(q\)</span>的法余矢。</p><p><span class="math inline">\(v^a \in W&#39;, v(f) = 0 = v^a \nabla_a f\)</span></p><p>第一式来源于超曲面其上的矢量的定义，第二个来源于导数算符对矢量作用的改写，最后的式子表示<span class="math inline">\(\nabla_a f\)</span>映射所有<span class="math inline">\(W&#39;\)</span>内的向量等于0，根据对偶矢量的定义且$_a f  $可知该对偶矢量满足法余矢的定义。</p><h2 id="法矢">法矢</h2><p>对法余矢用度规升成的矢量称为法矢，法矢在<span class="math inline">\(W&#39;\)</span>中的条件：<span class="math inline">\(g^{ab}n_an_b = 0\)</span>，不证了捏</p><h1 id="诱导度规和投影映射">诱导度规和投影映射</h1><p>令超曲面上的张量场<span class="math inline">\(h_{ab}\)</span>为度规，当<span class="math inline">\(h_{ab} w^aw^b = g_{ab}w^aw^b\)</span>，一般令诱导度规写为<span class="math inline">\(h_{ab} = g_{ab} \mp n_an_b\)</span>，正负号取决于<span class="math inline">\(n^an_a\)</span>的符号，<span class="math inline">\(n^an_a =1\)</span>时取负号，<span class="math inline">\(n^an_a = -1\)</span>时取正号，容易验证满足前面的定义。令投影算符表示为</p><p><span class="math display">\[h^a_{\enspace b} = g^{ac}h_{cb}= \delta^{a}_{\enspace b} \mp n^an_c\]</span></p><p>容易验证投影某个矢量场<span class="math inline">\(v^a = h^a_{\enspace b} v^b \pm n^a (n_bv^b)\)</span>，后面是<span class="math inline">\(n^a\)</span>的分量，而前半部分与<span class="math inline">\(n^a\)</span>缩并为0。</p>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.killing场</title>
    <link href="/2022/12/09/gr4/"/>
    <url>/2022/12/09/gr4/</url>
    
    <content type="html"><![CDATA[<h1 id="killing场和超曲面">killing场和超曲面</h1><h2 id="killing场定义">killing场定义：</h2><p>假设流形<span class="math inline">\((M,g_{ab})\)</span>上<span class="math inline">\(v\)</span>矢量场对应的单参微分同胚映射是保度规映射，既<span class="math inline">\(\phi_t^* g_{ab} = g_{ab}\)</span>，则称<span class="math inline">\(v\)</span>为killing场</p><h2 id="theorem1">theorem1:</h2><p><span class="math inline">\(v\)</span>是killing场等价于<span class="math inline">\(g_{ab}\)</span>关于<span class="math inline">\(v\)</span>的李导数等于0等价于killing方程：</p><p><span class="math display">\[\nabla_av_b +\nabla_bv_a = 0 \]</span></p><p>证明：</p><p>由李导数的定义</p><div style="text-align:center"><span class="math inline">\(\mathscr{L}_v g_{ab} = \lim_{t \rightarrow 0}\frac{\phi_t^*g_{ab}-g_{ab}}{t}\)</span></div><p>显然<span class="math inline">\(v\)</span>是killing场可直接推出<span class="math inline">\(g_{ab}\)</span>关于<span class="math inline">\(v\)</span>的李导数等于0，反过来，由李导数等于0，选取适配坐标系，得到：<span class="math inline">\(\frac{\partial g_{\mu\nu}}{\partial x_1}=0\)</span>，所以<span class="math inline">\(g_{\mu\nu}\)</span>在积分曲线上积分曲线相连的两点值相等。</p><p>设<span class="math inline">\(\phi\)</span>从<span class="math inline">\(p\)</span>点映射到<span class="math inline">\(q\)</span>点</p><span class="math display">\[\begin{aligned}g_{\mu\nu}\mid_q &amp;= g_{ab}(\frac{\partial}{\partial x^\mu})^a (\frac{\partial}{\partial x^\nu})^b\mid_q\\\\\phi_t^* g_{\mu\nu}\mid_q &amp;= \phi_t^* (g_{ab}(\frac{\partial}{\partial x^\mu})^a (\frac{\partial}{\partial x^\nu})^b)\mid_q\end{aligned}\]</span><div style="text-align:center">$ = _a^c _b^d ( _t^*g_{ab}_t^*()^c _t^*()^d)_p$</div><span class="math display">\[\begin{aligned}&amp;\phi_t^*(\frac{\partial}{\partial x^\nu})^c \mid_p f(p)\\\\=&amp; \phi_{-t*}(\frac{\partial}{\partial x^\nu})^c \mid_p f(p)\\\\ =&amp; (\frac{\partial}{\partial x&#39;^\nu})^c\mid_q f(\phi_{-t}(q))\end{aligned}\]</span><p>由适配坐标系的定义: <span class="math inline">\(f(\phi_{-t}(q)) = F&#39;(x&#39;^{1}-t,x&#39;^{2},x&#39;^{3}...x&#39;^{n}) = F(x^1,x^2,...x^n)\)</span></p><p>所以</p><span class="math display">\[\begin{aligned}&amp;\phi_t^* (\frac{\partial}{\partial x&#39;^\nu})^c\mid_p f(p)\\\\&amp; = (\frac{\partial}{\partial x&#39;^\nu})^c\mid_q f&#39;(q) = \frac{\partial F&#39;}{\partial x&#39;^\nu}  = \frac{\partial F}{\partial x^\nu}\\\\&amp; =  (\frac{\partial}{\partial x^\nu})^c\mid_p f(p)\end{aligned}\]</span><p>得到$_t^*()^c _p =()^c _q $，所以：</p><div style="text-align:center">$ _a^c _b^d ( _t^*g_{ab}_t^*()^c _t^*()^d)_p$</div><p><br></p><div style="text-align:center"><span class="math inline">\(= \delta_a^c \delta_b^d ( \phi_t^*g_{ab}\otimes (\frac{\partial}{\partial x^\mu})^c \otimes (\frac{\partial}{\partial x^\nu})^d)\mid_p\)</span></div><p><br></p><div style="text-align:center"><span class="math inline">\(g_{\mu\nu} \mid_q = \phi_t^*g_{\mu\nu} \mid_p\)</span></div><p>最后由在积分曲线上<span class="math inline">\(g_{\mu\nu}\)</span>为常数得到<span class="math inline">\(\phi_t^* g_{ab} = g_{ab}\)</span>，一二等价证毕</p><p>由李导数作用于二阶张量的运算法则由：</p><div style="text-align:center"><span class="math inline">\(\mathscr{L}_v(g_{ab}) = v^c \nabla_c g_{ab} + g_{ac} \nabla_b v^c + g_{cb} \nabla_a v^c\)</span></div><p><br></p><div style="text-align:center">$ = _b v_a + _a v_b = 0 $</div><h2 id="theorem-2">theorem 2:</h2><p>如果度规张量的所有分量关于某个坐标<span class="math inline">\(x\)</span>的导数为0，则<span class="math inline">\(x\)</span>的坐标基矢是killing矢量场。</p><p>选取该坐标基矢场<span class="math inline">\((\frac{\partial }{\partial x})^a\)</span>的适配坐标系，则得</p><div style="text-align:center"><span class="math inline">\(\mathscr{L}_{v}g_{ab}=0\)</span></div><h2 id="theorem-3">theorem 3:</h2><p><span class="math inline">\(T\)</span>是测地线的切矢，<span class="math inline">\(v\)</span>是killing矢量场，有：<span class="math inline">\(T^a\nabla_a (T^bv_b) = 0\)</span>，也就是说killing场和切矢的内积沿测地线不变</p><span class="math display">\[\begin{aligned}&amp;T^a\nabla_a (T^bv_b) \\\\ &amp;= v_b T^a\nabla_a T^b +T^b T^a\nabla_a v_b\\\\ &amp;=  T^{(b} T^{a)}\nabla_a v_b\\\\ &amp;=  T^{(b} T^{a)}\nabla_{[a} v_{b]}\\\\ &amp;=  0\end{aligned}\]</span><p>第一行是莱布尼兹律，第二行来源于测地线定义，第三行是同一个向量不同抽象记号可以加对称记号，第四行是因为killing矢量场<span class="math inline">\(\nabla_a v_b + \nabla_b v_a = 0 \Rightarrow \nabla_{[a} v_{b]} = \nabla_{a} v_{b}\)</span></p><h2 id="theorem-4">theorem 4:</h2><p>一个n维流形最多有<span class="math inline">\(\frac{n(n+1)}{2}\)</span>个killing矢量场。（未证）</p><h2 id="theorem-5">theorem 5:</h2><p>证明二维闵氏空间的boost-killing矢量场与洛伦兹变换对应。</p><p>boost矢量场：<span class="math inline">\(v= t(\frac{\partial}{\partial x})^a +x(\frac{\partial}{\partial t})^a\)</span></p><p>首先证明它在二维闵氏空间是killing矢量场。</p><p>先给出一对新坐标，<span class="math inline">\((\phi,\eta)\)</span>，st, <span class="math inline">\(x = \eta \cosh \phi, t = \eta \sinh \phi\)</span>, 通过坐标变换轻易将<span class="math inline">\(g_{ab}\)</span>展开为<span class="math inline">\((d\eta)_a(d\eta)_b - \eta^2 (d\phi)_a(d\phi)_b\)</span>，由theorem2，得到：<span class="math inline">\(\phi\)</span>的坐标基矢场是killing矢量场。通过坐标变换的关系易得</p><p><span class="math display">\[(\frac{\partial}{\partial \phi})^a= t(\frac{\partial}{\partial x})^a +x(\frac{\partial}{\partial t})^a\]</span></p><p>假设点<span class="math inline">\(q(t_0,x_0) or (phi_0,\eta_0 )\)</span>，通过boost-killing矢量场的单参微分同胚群元<span class="math inline">\(\phi_\Delta\)</span>映射到了<span class="math inline">\(q\)</span>，则由被动观点可知，<span class="math inline">\(q\)</span>的坐标可以视作<span class="math inline">\(p\)</span>的新坐标，欲求解q点为起点的积分曲线，由切矢在坐标基矢的展开式表达式：</p><p><span class="math display">\[(\frac{\partial}{\partial t})^a =\frac{d x^\mu}{dt} (\frac{\partial}{\partial x^\mu})^a\]</span></p><p>得到：</p><span class="math display">\[\begin{aligned}&amp;\frac{d x}{d\phi} = t \enspace \frac{d t}{d\phi} = x\\\\ &amp; x(\phi) = A \cosh \phi + B  \sinh \phi\\\\ &amp;t = A \sinh \phi + B  \cosh \phi\end{aligned}\]</span><p>再带入初始条件得到<span class="math inline">\(A=x_0\)</span>，<span class="math inline">\(B=t_0\)</span></p><p>令<span class="math inline">\(tanh=v\)</span>，则<span class="math inline">\(sinh= (v^{-2}-1)^{-\frac{1}{2}}\)</span>，<span class="math inline">\(cosh=(1-v^2)^{-\frac{1}{2}}\)</span></p><p>化简即为：</p><span class="math display">\[\begin{aligned}x = \frac{1}{\sqrt{1-v^2}} (x_0+vt_0)\\\\ t = \frac{1}{\sqrt{1-v^2}} (t_0 +vx_0)\end{aligned}\]</span>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内积空间</title>
    <link href="/2022/12/09/linear_algebra3/"/>
    <url>/2022/12/09/linear_algebra3/</url>
    
    <content type="html"><![CDATA[<h1 id="内积空间">内积空间</h1><h2 id="定义">定义：</h2><p>在线性空间的基础上定义了内积运算的空间，内积运算需满足以下性质：</p><span class="math display">\[\begin{aligned}&amp;\left&lt;u,u \right&gt; \ge 0 \\\\&amp;\left&lt;u_1+u_2,v \right&gt; = \left&lt;u_1,v \right&gt; + \left&lt;u_2,v \right&gt;\\\\&amp;\left&lt;\lambda u,v \right&gt; = \lambda \left&lt;u,v \right&gt;\\\\&amp;\left&lt;u,v \right&gt;^* = \left&lt;v,u \right&gt;\\\\&amp;if \enspace  \left&lt;u,u \right&gt; = 0 \Rightarrow u = 0\end{aligned}\]</span><p>我认为可以看作是一类度规的定义</p><p>由定义轻易有：</p><span class="math display">\[\begin{aligned}&amp;\left&lt;u,v_1 + v_2 \right&gt;=\left&lt;u,v_1\right&gt;+\left&lt;u,v_2\right&gt;\\\\&amp;\left&lt;u,0\right&gt; = \left&lt;0,v\right&gt; = 0\end{aligned}\]</span><h2 id="范数norm">范数（norm）</h2><p>定义为<span class="math inline">\(\sqrt{\left&lt;v,v \right&gt;}\)</span>, 记作<span class="math inline">\(||v||\)</span></p><h3 id="properties">properties:</h3><ol type="1"><li><span class="math inline">\(||v|| =0 \Rightarrow v = 0\)</span></li><li><span class="math inline">\(||\lambda v|| = |\lambda|\enspace ||v||\)</span></li></ol><h2 id="正交">正交：</h2><p>定义为$&lt;u,v &gt; =0 $，则称 <span class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span> 正交</p><p>Pythagorean Theorem：如果 <span class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span> 正交，则<span class="math inline">\(||v+u||^2 = ||v||^2 +||u||^2\)</span></p><h2 id="cauchyschwarz-inequality">Cauchy–Schwarz Inequality：</h2><p><span style="text:align:center"></p><p><span class="math inline">\(|\left&lt;v,u \right&gt;| \le ||u||\enspace ||v||\)</span></p><p></span></p><p><mark>分解</mark>：易证得如果 <span class="math inline">\(v \ne 0\)</span>，任意一个向量<span class="math inline">\(u\)</span>都可以表示为：<span class="math inline">\(u = \frac{\left&lt;u,v \right&gt;}{||v||^2}v+ w\)</span>，其中<span class="math inline">\(w = u - \frac{\left&lt;u,v\right&gt;}{||v||^2}v\)</span>，<span class="math inline">\(w\)</span>与<span class="math inline">\(v\)</span>正交</p><span class="math display">\[\begin{aligned}&amp; (||u||\enspace  ||v||)^2  = \left&lt;u,u \right&gt;\left&lt;v,v \right&gt;\\\\&amp; = \left&lt;cv+w,cv+w \right&gt;\left&lt;v,v \right&gt;\\\\&amp; = (c^2\left&lt;v,v \right&gt;+\left&lt;w,w \right&gt;)\left&lt;v,v \right&gt;\\\\&amp; \ge  c^2\left&lt;v,v \right&gt;^2\\\\&amp; = \left&lt;u,v \right&gt;^2\end{aligned}\]</span><h2 id="三角不等式">三角不等式</h2><p><span class="math display">\[||u+v||\le ||u||+||v||\]</span></p><p>prove:</p><span class="math display">\[\begin{aligned}&amp;\left&lt;u+v,u+v\right&gt; = ||u||^2+||v||^2+2Re(\left&lt;u,v\right&gt;)\\\\&amp; \le ||u||^2+||v||^2+2|\left&lt;u,v\right&gt;|\\\\&amp;  \le ||u||^2+||v||^2+2||u||\enspace ||v||\\\\&amp; \le (||u||+||v||)^2\end{aligned}\]</span><p>第二行是因为复数的模长大于等于实部长度，第三行有柯西施瓦兹不等式。</p><h2 id="parallelogram-equality">Parallelogram Equality</h2><p><span class="math inline">\(||u+v||^2 + ||u-v||^2 =2 (||u||^2+||v||^2)\)</span> 易证</p><h1 id="习题">习题</h1><h2 id="a.3">6.A.3</h2><p><img src="屏幕截图 2022-12-09 164406.png"></p><p>问题的关键点在于证明数域是实数域的时候，由存在某个矢量的范数大于0以及内积的其他性质可推得所有矢量的模的正定性。</p><p>假设<span class="math inline">\(v\)</span>与自己的内积大于0，<span class="math inline">\(u\)</span>与自己的内积小于0，则设矢量：<span class="math inline">\(w_t = v+(1-t)(u-t)\)</span></p><p>设<span class="math inline">\(f(t) = \left&lt;w_t,w_t\right&gt; = (1-t)^2 \left&lt;v,v\right&gt;+t^2\left&lt;u,u\right&gt;\)</span>，再由实连续函数的介值定理，存在一个t_0属于<span class="math inline">\([0,1]\)</span>，st,<span class="math inline">\(f(t_0) = 0\)</span></p><p><span class="math inline">\(v_{t_0}\)</span>与自己的内积等于0，可知<span class="math inline">\(v_{t_0}=0\)</span>，所以<span class="math inline">\(v\)</span> 与<span class="math inline">\(u\)</span>共线，所以矛盾，证毕</p><h2 id="a.9">6.A.9</h2><p><img src="屏幕截图 2022-12-09 164332.png"></p><p>显然不等式左右两边都大于0，将待求不等式左右两边同时平方得：</p><p><span class="math display">\[||u||^2 +||v||^2 -||u||^2\enspace ||v||^2 \ge 2|\left&lt;u,v\right&gt;|- |\left&lt;u,v\right&gt;|^2\]</span></p><p>同时对左边进行缩放：</p><p><span class="math inline">\(lms \ge 2||u||\enspace ||v|| - (||u||\enspace ||v||)^2\)</span></p><p>令f(x) = <span class="math inline">\(2x -x^2\)</span>，则 <span class="math inline">\(lms \ge f(||u||\enspace ||v||),rms = f(|\left&lt;u,v\right&gt;|)\)</span>，由<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([0,1]\)</span>的变化趋势以及<span class="math inline">\(||u||\enspace ||v|| \ge |\left&lt;u,v\right&gt;|\)</span>可知，<span class="math inline">\(lms\ge f(||u||\enspace ||v||) \ge f(|\left&lt;u,v\right&gt;|)=rms\)</span>，证毕</p><h2 id="a.12">6.A.12</h2><p><img src="屏幕截图 2022-12-09 165649.png"></p><p>由<span class="math inline">\(R^n\)</span>欧式内积空间上的<span class="math inline">\((x_1,x_2,...x_n)\)</span>与<span class="math inline">\((1,1,1,..,1)\)</span>的Cauchy–Schwarz不等式易证得。</p><h2 id="a.18">6.A.18</h2><p><img src="屏幕截图 2022-12-12 183808.png"></p><p>由三角不等式有：</p><p><span class="math inline">\(((x_1+x_2)^p+(y_1+y_2)^p)^{\frac{1}{p}}\le (x_1^p+y_1^p)^{\frac{1}{p}}+(x_2^p+y_2^p)^{\frac{1}{p}}\)</span></p><p>取点<span class="math inline">\((x_1,y_1)=(1,-1),(x_2,y_2)=(1,1)\)</span>，得到不等式：</p><p><span class="math display">\[4&lt;  (1+(-1)^p){\frac{1}{p}}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数, linear algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.推前拉回映射和李导数</title>
    <link href="/2022/12/07/gr3/"/>
    <url>/2022/12/07/gr3/</url>
    
    <content type="html"><![CDATA[<h1 id="拉回和推前映射">拉回和推前映射</h1><p>假设 <span class="math inline">\(\phi\)</span> 是从流形<span class="math inline">\(M\)</span>映射到流形<span class="math inline">\(N\)</span>的映射，则拉回映射<span class="math inline">\(\phi^*:\mathscr{F}_N \rightarrow \mathscr{F}_M\)</span> 定义为:</p><p><span style="text-align:center"><span class="math inline">\(\phi^* (f)\mid _p = f(\phi(p))\)</span><span></p><p><span class="math inline">\(p\)</span>是流形<span class="math inline">\(M\)</span>上的点，<span class="math inline">\(f\)</span>是流形<span class="math inline">\(N\)</span>上的标量场，有了拉回映射后，可以定义推前映射：</p><p><span style="text-align:center"></p><p><span class="math inline">\([\phi_* (v)] f = v (\phi^* f)\)</span></p><p></span></p><p><span class="math inline">\(v\)</span>是<span class="math inline">\(M\)</span>上的矢量场，<span class="math inline">\(f\)</span>是<span class="math inline">\(N\)</span>上的标量场。进一步可以推广到<span class="math inline">\((0,l),(l,0)\)</span>型的张量：</p><p><span style="text-align:center"></p><p><span class="math inline">\([\phi^* T_{ab...}]v_1^av_2^b ... = T_{ab...} (\phi_* v_1^a)(\phi_* v_2^b)..\)</span></p><p>importantly, <span class="math inline">\((\phi^* w_a) v^a = w_a (\phi^* v^a)\)</span> is well defined.</p><p>so:</p><p><span class="math inline">\([\phi_* T^{ab...}]w_a^1w_b^1 ... = T^{ab...} (\phi^* w_a^1)(\phi^* w_b^1)..\)</span></p><p></span></p><p>假如<span class="math inline">\(\phi\)</span>是微分同胚，进一步可以推广到<span class="math inline">\((k,l)\)</span>型张量，以<span class="math inline">\((1,1)\)</span>型为例</p><p><span style="text-align:center"></p><p><span class="math inline">\((\phi^* T_a^{\enspace b})v^aw_b =T_a^{\enspace b}(\phi_*v^a)(\phi_*w_b)\)</span></p><p><span class="math inline">\((\phi_* T_a^{\enspace b})v^aw_b =T_a^{\enspace b}(\phi^* v^a)(\phi^* w_b)\)</span></p><p></span></p><p>第一个式子将 <span class="math inline">\(N\)</span> 上的张量映射到 <span class="math inline">\(M\)</span> 上，此处<span class="math inline">\(\phi_* w\)</span>的和<span class="math inline">\(\phi^* v\)</span>没有定义，则定义</p><p><span style="text-align:center"></p><p><span class="math inline">\(\phi^* v = \phi^{-1}_{*}v\)</span></p><p><span class="math inline">\(\phi_* w = \phi^{-1*}w\)</span></p><p></span></p><h2 id="主被动观点和新新老老老新">主被动观点和“新新老=老老新”：</h2><blockquote><p>由于<span class="math inline">\(M\)</span>和<span class="math inline">\(N\)</span>微分同胚，主动观点指认为映射<span class="math inline">\(\phi\)</span>将<span class="math inline">\(M\)</span>上的点和张量等变换了<span class="math inline">\(N\)</span>上，而被动观点认为映射<span class="math inline">\(\phi^{-1}\)</span>将<span class="math inline">\(N\)</span>的点和张量的基(以及张量)映射到了<span class="math inline">\(M\)</span>上，从而导致了<span class="math inline">\(M\)</span>引入了一个新基，所以认为映射<span class="math inline">\(\phi\)</span>引入了一个坐标变换。</p></blockquote><blockquote><p>新点（<span class="math inline">\(\phi(p)\)</span>）的新张量<span class="math inline">\((\phi_* T)\)</span>在老坐标系（<span class="math inline">\(N\)</span>上的原有坐标系<span class="math inline">\({(\frac{\partial }{\partial x^\nu})^a}\)</span>）的展开分量等于老点（<span class="math inline">\(p\)</span>）的老张量（<span class="math inline">\(T\)</span>）在新坐标系（<span class="math inline">\(\phi^*{(\frac{\partial }{\partial x^\nu})^a}\)</span>，由<span class="math inline">\(N\)</span>上的原有坐标系在<span class="math inline">\(M\)</span>上诱导出来的新坐标系）的展开分量。</p></blockquote><blockquote><div style="text-align:center"><span class="math inline">\(\phi_{*}T^{\nu_1\nu_2...}_{\enspace\enspace\mu_1\mu_2...}\mid _{\phi_t(p)}\)</span> = <span class="math inline">\(T_{v_1v_2...}^{\quad \nu_1\nu_2...}|_p\)</span></div></blockquote><blockquote><p>prove: （以(1,1)型张量为例）</p></blockquote><div style="text-align:center"><span class="math inline">\((\phi_*T)_{\mu}^{\;\; \nu}|_{\phi(p)}\)</span>=<span class="math inline">\((\phi_*T)_{a}^{\;\; b}(\frac{\partial}{\partial x^\mu})^a (dx^\nu)_b|_{\phi(p)}\)</span></div><p><br></p><div style="text-align:center"><p><span class="math inline">\(=(T)_{a}^{\enspace b}(\phi^*\frac{\partial }{\partial x^\mu})^a (\phi^*dx^\nu)_b \mid _{p}\)</span></p></div><blockquote><p>第一个等号来自于分量定义，第二个等号来自于推前映射的定义，</p></blockquote><h1 id="李导数">李导数</h1><h2 id="定义">定义：</h2><p>给定一个矢量场<span class="math inline">\(v\)</span>，则由该矢量场可以给出一个单参微分同胚群，记作<span class="math inline">\(\phi_t\)</span>，则李导数定义为：</p><div style="text-align:center"><span class="math inline">\(\mathscr{L}_v T^{..}_{..}\)</span>=<span class="math inline">\(\lim_{t\rightarrow0} \frac{\phi_{t}^{*}T^{...}_{...} -T^{...}_{...}}{t}\)</span></div><h2 id="theorem1-mathscrl_v-f-vf">theorem1: <span class="math inline">\(\mathscr{L}_v f = v(f)\)</span></h2><p>首先，矢量场所给出的单参微分(局域的)同胚群满足：取一点<span class="math inline">\(p\)</span>为起点，则由矢量场给定的积分曲线有<span class="math inline">\(C(t) = \phi_t(p)\)</span></p><div style="text-align:center"><span class="math inline">\(\mathscr{L}_v f\)</span>=<span class="math inline">\(\lim_{t\rightarrow0} \frac{\phi_t^*f - f}{t}\)</span>=<span class="math inline">\(\lim_{t\rightarrow0} \frac{f(\phi_t(p)) - f(p)}{t}\)</span>=<span class="math inline">\(\lim_{t\rightarrow0} \frac{f(C(t))- f(C(0))}{t}\)</span></div><p><br></p><div>最后一式即为<span class="math inline">\(\frac{\partial }{\partial t}(f)\)</span>定义</div><h2 id="theorem2">theorem2:</h2><div>在适配坐标系下，<span class="math inline">\(\mathscr{L}_v T^{...}_{...}\)</span> = <span class="math inline">\(\frac{\partial T_{...}^{...}}{\partial x_1}\)</span></div><p><mark>适配坐标系</mark>即以p的坐标<span class="math inline">\((0,x_2,x_3,...)\)</span>，p的积分曲线<span class="math inline">\(C(t)\)</span>上的点<span class="math inline">\(q\)</span>的坐标为<span class="math inline">\((t,x_2,x_3,...)\)</span>，<span class="math inline">\(v\)</span>为<span class="math inline">\(\frac{\partial }{\partial x_1}\)</span>的坐标系。</p><p>便于说明，采用<span class="math inline">\((1,1)\)</span>型张量</p><div style="text-align:center"><span class="math inline">\(\mathscr{L} T^{\enspace \mu}_{\nu}\)</span>=<span class="math inline">\(\lim_{t\rightarrow 0} \frac{\phi_{t}^{*}T^{\enspace \mu}_{\nu} -T^{\enspace \mu}_{\nu}}{t}\)</span> =<span class="math inline">\(lim_{t\rightarrow 0} \frac{\phi_{-t*}T^{\enspace \mu}_{\nu} -T^{\enspace \mu}_{\nu}}{t}\)</span></div><p><br></p><div>由推前映射的新点新张量在老坐标系下的展开等于“老老新”有，<span class="math inline">\(\phi_{-t*}T^{\enspace \mu}_{\nu}\mid _{p}\)</span>=<span class="math inline">\(T&#39;^{\enspace \mu}_{\nu}\mid _{\phi(t)(p)}\)</span></div><p>再由老点由<span class="math inline">\(\phi^{-1}\)</span>诱导的新坐标等于新点在老坐标系下的坐标有（可以证明这样规定的新坐标是微分同胚映射）：</p><p><span class="math inline">\(x&#39;^{\mu}=x&#39;^{\mu}+t\delta_{1\mu}\)</span></p><p>所以</p><div style="text-align:center"><span class="math inline">\(T&#39;^{\enspace \mu}_{\nu}\mid _{\phi(t)(p)}\)</span> = <span class="math inline">\((\frac{\partial x&#39;^\mu}{\partial x^\sigma}\frac{\partial x^\eta}{\partial x&#39;^\nu}T^{\enspace \sigma}_{\eta}\mid _{\phi(t)(p)})\)</span> = <span class="math inline">\(T^{\enspace \mu}_{\nu}\mid _{\phi(t)(p)}\)</span></div><p>所以李导数写为:</p><div style="text-align:center"><span class="math inline">\(\mathscr{L} T^{\enspace \mu}_{\nu}\)</span> = <span class="math inline">\(\lim_{t\rightarrow 0} \frac{T^{\enspace \mu}_{\nu}\mid _{\phi_t(p)} -T^{\enspace \mu}_{\nu}\mid _{p}}{t}\)</span></div><p><br></p><div style="text-align:center"><span class="math inline">\(= (\frac{\partial }{\partial t})T^{\enspace \mu}_{\nu}\)</span> = $()T^{}_{} = $</div><h2 id="theorem3">theorem3:</h2><p><span class="math inline">\(\mathscr{L}_v u^a = [v,u]^a\)</span> and <span class="math inline">\(\mathscr{L}_v w_a = v^a \nabla_b w_a+ w^a \nabla_b v_a\)</span></p><p>显然根据李导数的定义，与坐标系的选择无关，所以为了简化证明，可以选择适配坐标系，现证明第二条：</p><p><span class="math inline">\(\mathscr{L}_v (w_av^a)= v(w_a v^a) = v_b \nabla^b(w_av^a) = v^b(w_a\nabla_bv^a + v^a\nabla_b w_a)\)</span></p><p>第一个等号来源于李导数对标量场的作用，第二个来源于导数算符对矢量作用的改写，同时：</p><p>再由theorem2和偏微分求导的莱布尼兹律说明李导数满足莱布尼兹律，则：</p><p><span class="math inline">\(\mathscr{L}_v (w_bv^b) = w_a \mathscr{L}_v (v^b) + v^b\mathscr{L}_v (w_b)\)</span></p><p>$ =w_b [v,v]^b + v^b_v (w_b) = v^b_v (w_b)$</p>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基和向量</title>
    <link href="/2022/12/07/linear_algebra2/"/>
    <url>/2022/12/07/linear_algebra2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数, linear algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性空间</title>
    <link href="/2022/12/06/linear_algebra1/"/>
    <url>/2022/12/06/linear_algebra1/</url>
    
    <content type="html"><![CDATA[<h1 id="vector-space">Vector Space</h1><h2 id="vector-space-1">1.1 vector space</h2><p><span id="1.1"> A vector space </span> is a set (denoted by <span class="math inline">\(V\)</span>) along with an addition and a scalar multiplication satisfying the following properties.</p><span class="math display">\[\begin{aligned}\forall &amp;u,v,w \in V, a,b \in F\\\\&amp;(1)u+v = v+u\\\\&amp;(2)(u+v)+w = u+(v+w)\\\\ &amp;(3)\exists \enspace 0, st\enspace 0+u = 0\\\\ &amp;(4)\exists \enspace h, st\enspace h+u = 0\\\\ &amp;(5)\exists \enspace 1, st\enspace 1u=u\\\\ &amp;(6)a(u+v)=au+av,(a+b)u=au+bu\end{aligned}\]</span><h2 id="fs">1.2 <span class="math inline">\(F^S\)</span></h2><p><span class="math inline">\(F^S\)</span> denotes a function from S to F, such as <span class="math inline">\(F^2\)</span>,$F^ $, $ R^{[1,2]}$, and <span class="math inline">\(F^n\)</span> also can be expressed by <span class="math inline">\(\\{x_1,x_2,......, x_n:x_i \in F \enspace for \enspace i =1,2,3,...,n \\}\)</span></p><p>the scalar multiplication and addition are defined by:</p><span class="math display">\[\begin{aligned}&amp;f,g \in F^S, x \in S\\\\&amp;(f+g)(x)=f(x)+g(x)\\\\&amp;(\lambda g)(x)= \lambda g(x)\end{aligned}\]</span><h2 id="unique-additive-identity-and-unique-additive-inverse">1.3 unique additive identity and unique additive inverse</h2><p>prove:</p><p>(zero here means vector 0)</p><span class="math display">\[\begin{aligned}&amp; suppose \enspace \exists 0,0&#39;,\forall v \in V,\\\\&amp;0= v+(-v)=(0&#39;+ v )+(-v)=0&#39;+(v+-v)=0&#39;+0=0&#39;\\\\\&amp;therefore \enspace  0=0&#39;\\\\&amp;suppose \enspace  \exists w,w&#39;,st \enspace w+v=0,w&#39;+v=0\\\\&amp;w = 0 + w=(w&#39;+v)+w=w&#39;\\\\&amp;\therefore w = w&#39;\end{aligned}\]</span><h2 id="vector-0-and-number-0">1.4 vector 0 and number 0</h2><span class="math display">\[\begin{aligned} 0v&amp;=(0+0)v=0v+0v\\\\  \therefore 0v &amp;= 0\\\\  a0_v&amp;=a(v-v)=av -av=0_v\end{aligned}\]</span><h2 id="times-v">1.5 -1 times v</h2><p><span id="1.5"></p><span class="math display">\[\begin{aligned}0_v&amp;=(1+(-1))v=v+(-1)v\\\\0_v&amp;=v+(-v)\\\\\therefore -1v&amp; = -v\end{aligned}\]</span><p></span></p><h2 id="subspace">1.6 subspace</h2><p>A subset of V is a subspace if it inherites addition and multiplication defined on V and it is a vector space.</p><p><span id="1.7"></p><h2 id="conditions-for-a-subspace">1.7 conditions for a subspace</h2><p>U is a subspace of V if and only if:</p><span class="math display">\[\begin{aligned}&amp;(1)0_v \in U\\\\ &amp;(2)\forall u,w \in U\Rightarrow u+w \in U\\\\ &amp;(3)\forall a\in F,v\in U, av \in U\end{aligned}\]</span><p>I'll deduce <span class="math inline">\(U\)</span> is a linear space <a href="#1.1">1.1</a> from the assumptions above.</p><p><a href="#1.1">1.1</a>(1),(2) is easy to get because U is the subset of V and condition(2) ensures <span class="math inline">\(v+w \in U\)</span>.</p><p><a href="#1.1">1.1</a>(3) is equal to condition(2).</p><p><a href="#1.1">1.1</a>(4): according to condition(3)，we could know <span class="math inline">\(-v = -1v \in U\)</span> (see <a href="#1.5">1.5</a>) , which means every element has its own additive inverse in <span class="math inline">\(U\)</span></p><p><a href="#1.1">1.1</a>(5) <span class="math inline">\(1 \in F\)</span></p><p><a href="#1.1">1.1</a>(6) can be seen as <span class="math inline">\(U\)</span> is a subset of <span class="math inline">\(V\)</span> and condition(2)(3) ensures <span class="math inline">\(av+bw \in U\)</span>.</p><p>conversely, easy to prove.</p><p></span></p><h2 id="sum-of-subspaces">1.8 sum of subspaces</h2><p><span class="math inline">\(U_1,U_2,......,U_n\)</span> are subsets of V, define sum of these subspaces by:</p><span class="math display">\[\begin{aligned}U_1+U_2......+U_n = \\{u_1+u_2+u_3...+u_n:u_i \in U_i,i=1,2,3...,n\\}\begin{aligned}If $U_1,U_2,......,U_n$ are subspaces of V and each element in $U_1+U_2......+U_n$ can only be expressed uniquely in $u_1+u_2+u_3+......+u_n$, we call $U_1+U_2......+U_n$  is a direct sum,we use $U_1 \oplus U_2 \oplus ..... U_n$ to denote it.## 1.9 condition of direct sum$U_1,U_2,......,U_n$ is subspace of V,  $U_1+U_2+U_3...+U_n$ is direct sum if and only if $0$ can only be expressed uniquely in $0_1+0_2+0_3......+0_n$prove:\begin{aligned}&amp;suppose \enspace 0 = 0_1+0_2+0_3......+0_n \\\\ &amp;if\enspace \exists u = u_1+u_2...+u_n=u_1&#39;+u_2&#39;...u_n&#39;\\\\ &amp;0 = u-u=(u_1&#39;-u_1)+(u_2&#39;-u_2)...+(u_n&#39;-u_n)\end{aligned}\]</span><p>Because 0 can only be expressed in one way, <span class="math inline">\(u_i = u_i&#39;\)</span>, which means <span class="math inline">\(U_1+U_2...+U_n\)</span> is a direct sum</p><p><span id="1.10"></p><h2 id="direct-sum-of-two-subspace">1.10 direct sum of two subspace</h2><p><span class="math inline">\(U_1+U_2\)</span> is a direct sum if and only if <span class="math inline">\(U_1 \cap U_2 =\\{0\\}\)</span></p><p>prove:</p><span class="math display">\[\begin{aligned}&amp;if\enspace U_1 \cap U_2 = \{0\}\\\\&amp;0 = u_1 + u_2\\\\&amp;u_1 \in U_1 u_2 \in U_2\\\\&amp;\because u_1 = -u_2 \in U_2\\\\&amp;\therefore u_1 \in U_1 \cap U_2\\\\&amp;\therefore u_1 = 0\end{aligned}\]</span><p><span class="math inline">\(U_1+U_2\)</span> is a direct sum, reversely,</p><span class="math display">\[\begin{aligned}\\\\&amp;U_1+U_2\enspace is\enspace direct\enspace sum\\\\&amp;\forall u \in U_1 \cap U_2\\\\ &amp;if\enspace u\ne0  \enspace u = 0_1 +u = u + 0_2\end{aligned}\]</span><p>Contradiction with assumptions, therefore <span class="math inline">\(u = 0\)</span></p><p></span></p><h1 id="exercise">exercise</h1><h2 id="b">1.B</h2><h3 id="b.1">1.B.1</h3><p><span style="text-align:center"></p><p><span class="math inline">\(-(-v)=-(-1v)=-1(-1v)=(-1 \times -1)v=v\)</span></p><p></span></p><h3 id="b.2">1.B.2</h3><p><span style="text-align:center"></p><p><span class="math inline">\(if\enspace a \ne 0,\frac{1}{a}0_v=0_v =(\frac{1}{a}\times av)=v\)</span></p><p></span></p><h3 id="b.3">1.B.3</h3><span class="math display">\[\begin{aligned}&amp;suppose\enspace \exists\vec{x}&#39;\enspace st\enspace 3\vec{x}&#39;+\vec{v}=\vec{w}\\\\&amp;3\vec{x}&#39;+\vec{v} = \vec{w}=3\vec{x}+\vec{v}\\\\&amp;\Rightarrow \vec{x}&#39;-\vec{x}= 0\end{aligned}\]</span><h3 id="b.5">1.B.5</h3><span class="math display">\[\begin{aligned}\exists0,st\enspace 0_v+u=u \Rightarrow 0v=0_v\enspace for\enspace \forall v \in V\\\\0_v=u-u=(1-1)u=0u\end{aligned}\]</span><h3 id="b.6">1.B.6</h3><p><span class="math inline">\(R \cup \{\infty\}\cup \{-\infty\}\)</span> is a vector space can be verified by checking the scalar multiplication and addition between infinity and constant.</p><h2 id="c">1.C</h2><h3 id="c.3">1.C.3</h3><span class="math display">\[\begin{aligned}&amp;\forall f,g \in U =\{f:f&#39;(-1)=3f(2),f \in \textbf{R}^{(-4,4)}\}\\\\&amp;(f+g)&#39;(-1)= f&#39;(-1)+g&#39;(-1) = 3f(2)+3g(2)= 3(f+g)(2)\\\\&amp;\therefore f+g \in U\\\\&amp;\\\\&amp;(\lambda f)&#39;(-1) = \lambda f&#39;(-1)=3 (\lambda f)(2)\\\\&amp;\therefore \lambda f \in U\\\\&amp;\\\\&amp; 0&#39;(-1)=3\enspace 0(2)=0\\\\&amp;\therefore 0\enspace is\enspace in\enspace U\end{aligned}\]</span><h3 id="c.6">1.C.6</h3><span class="math display">\[\begin{aligned}(a)&amp; a^3=b^3 \Rightarrow a = b\enspace when\enspace a,b \in \mathcal{R}\\\\(b)&amp; (1,e^{\pi i2/3},0)+(e^{\pi i4/3},1,0) \notin U\end{aligned}\]</span><h4 id="c.7">1.C.7</h4><p><span class="math inline">\(\\{(1,0),(0,0),(0,1)\\}\)</span> is closed under the addition but it is not closed under the scalar multiplication</p><h4 id="c.8">1.C.8</h4><p><span class="math inline">\((\lambda,2\lambda)\cup(\lambda,3\lambda) \lambda \in R\)</span> closed under the scalar multiplication but it is not closed under the addition</p><p><span id="1.C.10"></p><h4 id="c.10">1.C.10</h4><p>\begin{aligned} u,w U_1 U_2 \u+w ,u U_1 \ u+w,u U_2 \u+w, uU_1 U_2 obviously, 0isinthesubsetU_1 U_2 \begin{aligned}</p><p>therefore <span class="math inline">\(U_1 \cap U_2\)</span> is subspace satisfies the three conditions in <a href="#1.7">1.7</a>, <span class="math inline">\(U_1 \cap U_2\)</span> is a subspace.</p><p></span></p><h4 id="c.11">1.C.11</h4><p>using the same method in <a href="#1.C.10">1.C.10</a></p><p><span id="1.C.12"></p><h4 id="c.12">1.C.12</h4><p>from <a href="#1.C.10">1.C.10</a>,we can infer that <span class="math inline">\(U_1 \in U_2 \Rightarrow U_1 \cup U_2\)</span> is a subspace,</p><p>reversely,</p><p>\begin{aligned} U_1 U_2isasubspace \supposev U_1 / U_2 , u U_2 / U_1 (/heremeansquotientofsets) \U_1 U_2isasubspace \v+u U_1 U_2 \supposev+u U_1 \U_1isasubspace \u U_1 \contradicttotheassumption \v+u U_2 \v U_2 \contradicttotheassumption \Thenullhypothesisiswrong \U_1/U_2orU_2/U1isanemptyset \U_2 U_1 or U_1 U_2 \begin{aligned}</p><p></span></p><h4 id="c.13">1.C.13</h4><p>if there exists one subspace contains another, from <a href="#1.C.12">1.C.12</a> we can prove it easily.</p><p>and in another case, each of the three subspaces contains vector which is not contained by other subspaces:</p><p>\begin{aligned} _1 U_1 U_2 U_3 \_2 U_2 U_1 U_3 \_3 U_3 U_1 U_2 \begin{aligned}</p><p><span class="math inline">\(u_1 + u_2 \in U_1 \cup U_2 \cup U_3\)</span>, using the samemethodin <a href="#1.C.12">1.C.12</a> ,<span class="math inline">\(u_1 +u_2 \in U_3 \notin U_2\enspace and\enspace \notin U_1\)</span> can be deduced. and also <span class="math inline">\(u_1 +2u_2 \in U_3 \notin U_2\enspace and\enspace \notin U_1\)</span>, because <span class="math inline">\(U_3\)</span> is a subspace of V, <span class="math inline">\(u_2 = (u_1+2u_2)-(u_1+u_2) \in U_3\)</span>, it is contradict to the assumption. so this case should be discarded.</p><h4 id="c.18">1.C.18</h4><p>It is an example set which contains 0 but does not have addictive inverses.</p><h4 id="c.19---22">1.C.19 - 22</h4><p>19: <span class="math inline">\(W=\{(x,y,0):x,y \in \R\},\enspace U_1=\{(0,y,z):y,z \in \R\},\enspace U_2=\{(0,0,z):z \in \R\}\)</span> 20:<span class="math inline">\(\{(0,x,y,0):x,y \in F\}\)</span> 21:<span class="math inline">\(\{(0,0,x,0,0):x \in F\},\{(0,0,0,x,0):x \in F\},\{(0,0,0,0,x):x \in F\}\)</span></p><h4 id="c.23">1.C.23</h4><p>\begin{aligned} prove: \V = U_1 W \vU_1, v Vandv W \alsoV =U_2W \v U_2 \U_1 U_2 \reverselyU_2 U_1 \U_2 = U_1 \begin{aligned}</p><h4 id="c.24">1.C.24</h4><p>the function is odd and even:</p><p><span class="math inline">\(f(-x) =f(x)=-f(x) \Rightarrow f(x) = 0\\\therefore U_e \cup U_o = {0(x)} \Rightarrow U_e \oplus U_o\)</span></p><p>for all function <span class="math inline">\(g(x)\)</span> in <span class="math inline">\(\R^\R\)</span>, can be expressed by <span class="math inline">\(w(x)+v(x):w(x)=\frac{g(x)+g(-x)}{2},v(x)=\frac{g(x)-g(-x)}{2}\)</span>, where <span class="math inline">\(w(x)\)</span> is an even function, <span class="math inline">\(v(x)\)</span> is an odd function.</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数, linear algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绝热定理及贝瑞相</title>
    <link href="/2022/12/03/quantum1/"/>
    <url>/2022/12/03/quantum1/</url>
    
    <content type="html"><![CDATA[<h4 id="绝热定理">绝热定理</h4><p>当量子态开始绝热演化时，展开系数写为<span class="math inline">\(\psi(0)=\sum_{n}c_n\varphi_n(0)\)</span>, 则 <span class="math inline">\(t\)</span> 时刻的量子态写为：</p><p><span class="math display">\[\psi(t) = \sum_nc_n \varphi_n(t)e^{i\theta_n}e^{i\gamma_n}\]</span></p><p><span class="math inline">\(\varphi_n(t)\)</span>是哈密顿量在 <span class="math inline">\(t\)</span> 时刻的第n个本征态，</p><p><span class="math inline">\(\theta_n = -\frac{1}{\hbar}\int_0^{t}E_n(t)dt,~ \gamma_n = i\int_0^t\left&lt; \varphi_n|\dot{ \varphi_n}\right&gt; dt\)</span></p><p>证明：</p><p><span style="text-align:center"></p><p><span class="math inline">\(\left| \psi \right&gt;(t) = \sum_n C_n(t)e^{i\theta_{n}(t)}\left| n \right&gt;(t)\)</span></p><p><span class="math inline">\(\theta_{n}(t) = - \int \frac{E_n(t)}{\hbar}dt\)</span></p><p><span class="math inline">\(\left&lt;m\right| \left( t\right) i\hbar \dot{\left| \psi \right&gt;}\left( t\right)\)</span></p><p><span class="math inline">\(=i\hbar \left&lt; m\right|(\sum _{n}\dot{C_n(t)}e^{i\theta _{n}\left( t\right) }\left|n \right&gt;\left( t\right)\)</span></p><p><span class="math inline">\(+C_n(t)(i\dot\theta_n(t)e^{i\theta(t)}\left| n \right&gt;(t)+C_n(t)e^{i\theta_n(t)}\dot{\left|n\right&gt;}(t))\)</span></p><p><span class="math inline">\(\dot \theta (t) = -\frac{E_n(t)}{\hbar}\)</span></p><p><span class="math inline">\(= i\hbar \dot c_m(t)e^{i\theta_m(t)}+c_m(t)E_m(t)e^{i \theta _m(t)}+\sum_n c_n(t)e^{i\theta_n(t)}\left&lt; m\right|\dot{ \left| n\right&gt;}(t)\)</span></p><p><span class="math inline">\(\left&lt; m\right| (t)\hat H(t) \left| \psi \right&gt;(t)\)</span></p><p><span class="math inline">\(=\left&lt; m\right| (t)\hat H(t)\sum_i C_i(t)e^{i\theta_i(t)}\left|i\right&gt;(t)\)</span></p><p><span class="math inline">\(= E_m(t)C_m(t)e^{i\theta_m(t)}\)</span></p><p>$E_m(t)C_m(t)e^{i_m(t)} $</p><p><span class="math inline">\(= i\hbar \dot c_m(t)e^{i\theta_m(t)}+c_m(t)E_m(t)e^{i \theta _m(t)}+\sum_n c_n(t)e^{i\theta_n(t)}\left&lt; m\right|\dot{ \left| n\right&gt;}(t)\)</span></p><p><span class="math inline">\(\dot C_m(t) = \frac{i}{\hbar} \sum_n C_n(t) e^{i(\theta_n(t)-\theta_m(t))}\left&lt; m|\dot n \right&gt;\)</span></p><p><span class="math inline">\(According \quad to \quad \hat H \left|n \right&gt; = E_n \hat H \left|n \right&gt;\)</span></p><p>$&lt; m |  | n&gt; =( E_n -E_m ) &lt; m|n&gt; $</p><p><span class="math inline">\(if \quad m \ne n \dot{C_m}(t) = \frac{i}{\hbar} C_m(t)\left&lt;m|\dot m\right&gt; + \frac{i}{\hbar}\sum&#39;_n \frac{\left&lt; m\right| \dot {\hat H}\left|m\right&gt;}{E_n-E_m}\)</span></p><p></span></p><p>当第二项远远小于第一项时，称为绝热条件，则得到绝热定理，<span class="math inline">\(\left&lt;m|\dot m\right&gt;\)</span>为实数，则证明不会对振幅产生影响。</p><h4 id="berry-相">berry 相</h4><p><span class="math inline">\(\gamma_n = i\int_0^t\left&lt; \varphi_n|\dot{ \varphi_n}\right&gt;dt\)</span> 被称为几何相。假设系统 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(R\)</span> 的函数，<span class="math inline">\(R\)</span>是一些线性无关的参量，于是可以把系统演化看作是R空间中以参数 <span class="math inline">\(t\)</span> 来演化的的一条轨迹，当系统演化一个周期回到初态后，则：</p><p><span style="text-align:center"></p><p><span class="math inline">\(\gamma_n = i\int_0^t\left&lt; \varphi_n|\dot{ \varphi_n}\right&gt;dt\)</span></p><p>$ = i_0^t&lt; _n|_R |_n&gt;(R_i/t)~dt$</p><p><span class="math inline">\(= i\int_{R_0}^{R_T=R_0}\left&lt; \varphi_n|\nabla_R| \varphi_n\right&gt;\cdot d\vec{R}\)</span></p><p>$ =i _R&lt; _n|_R |_n&gt; dS$</p><p></span></p><p>称这个<span class="math inline">\(R_n\)</span>空间上的积分结果为berry相</p><p>（具体计算方法的分析以及流形参数空间R的讨论见微分几何与广义相对论附录）</p><p>某点的<span class="math inline">\(B_n(R) = \nabla_R\times \left&lt; \varphi_n|\nabla_R |\varphi_n\right&gt;\)</span>的计算公式：</p><p><span class="math display">\[B_n(R) = i \sum^{}_{m\ne n} \frac{\left&lt;n\right|(R)[\nabla_R H]\left|m\right&gt;(R)\times\left&lt;m\right|(R)[\nabla_R H]\left|n\right&gt;(R)}{(E_n-E_m)^2}\]</span></p><h4 id="自旋态二能级绝热演化推导">自旋态二能级绝热演化推导：</h4><p>假设原子在空间中受到磁场的作用 <span class="math inline">\(\hat H(t) = -\hat{\mu} \cdot B = -\frac{2\mu}{\hbar} \hat{S} \cdot B(t)\)</span>，<span class="math inline">\(B\)</span> 在随时缓慢旋转，所以可以将B本身视作参数空间，从而推导绝热演化的情况，初态位于<span class="math inline">\(S_z = \frac{\hbar}{2}\)</span> 态上</p><p>任意<span class="math inline">\(B\)</span>对应的本征值：</p><p><span style="text-align:center"></p><p><span class="math inline">\(\hat H = -\frac{2\mu}{\hbar} \hat{S} \cdot B(t)\)</span></p><p><span class="math display">\[ = -\mu B\left( \begin{matrix}    \cos \varphi&amp;       \cos \theta \sin \varphi +\sin \theta \sin \varphi i\\\\    \cos \theta \sin \varphi -\sin \theta \sin \varphi i&amp;       -\cos \varphi\\\\\end{matrix} \right)\\\\\]</span></p><p><span class="math display">\[E_{\pm}:root ~of: -\mu B\left| \begin{matrix}    \cos \varphi- \mu   &amp;   \cos \theta \sin \varphi +\sin \theta \sin \varphi i\\\\    \cos \theta \sin \varphi -\sin \theta \sin \varphi i&amp;       -\cos \varphi-\mu\\\\\end{matrix} \right|=0\\\\\]</span></p><p><span class="math inline">\(E_{\pm}= \pm \mu B\)</span></p><p></span></p><p>还需求 <span class="math inline">\(\left&lt; -\right| \nabla_B H \left| +\right&gt;\)</span>,<span class="math inline">\(\left&lt; +\right| \nabla_B H \left| -\right&gt;\)</span>来求解贝瑞相，</p><p><span class="math inline">\(\nabla_B H = - \frac{2\mu}{\hbar}(\hat S_x \nabla_B B_x+\hat S_y \nabla_B B_y +\hat S_z \nabla_B B_z) = - \frac{2\mu}{\hbar} \hat S\)</span></p><p>选取 <span class="math inline">\(\left| \pm\right&gt;\)</span> 为基，则<span class="math inline">\(S\)</span>表示为<span class="math inline">\(\frac{1}{2}(S_++S_-)\hat x + \frac{1}{2i}(S_+ - S_-)\hat y + S_Z \hat z\)</span>，则：<span class="math inline">\(\left&lt; \mp\right| \nabla_B H \left| \pm \right&gt;= \frac{\hbar}{2}(\hat x\mp i\hat y)\)</span>，此时的坐标系选择是以<span class="math inline">\(B\)</span>方向为<span class="math inline">\(Z\)</span>的坐标系。</p><p>带入求贝瑞项的公式得：<span class="math inline">\(D_\pm(B) = \mp \frac{1}{2\mu B^2}\vec B\)</span></p><p>则假设磁场由 <span class="math inline">\(B=B_0\hat z\)</span> 绝热变化一圈，则对应的 <span class="math inline">\(\left| +\right&gt;\)</span> 态积累的相因子：</p><p><span class="math inline">\(\phi_{Barry} = \oint_l D_+(\vec B) \cdot d\vec B\)</span>, <span class="math inline">\(l\)</span> 为<span class="math inline">\(B\)</span>在B空间内的演化路径</p>]]></content>
    
    
    <categories>
      
      <category>量子力学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantum mechanics, 量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.曲率张量及其性质</title>
    <link href="/2022/12/01/gr1/"/>
    <url>/2022/12/01/gr1/</url>
    
    <content type="html"><![CDATA[<h1 id="曲率张量">曲率张量</h1><p><span class="math inline">\(w_c,w_c&#39;\)</span>是流形上的两个不同的矢量场，矢量场在p点取值相同，可以证明：</p><p><span style="text-align: center"></p><p><span class="math inline">\((\nabla_a \nabla_b - \nabla_b \nabla_a)w_c|_p = (\nabla_a \nabla_b - \nabla_b \nabla_a)w_c&#39;|_p\)</span></p><p><span class="math inline">\(\Omega_c = w_c -w_c’\)</span></p><p>$(_a _b - _b _a)_c $</p><p><span class="math inline">\(= (\nabla_a \nabla_b - \nabla_b \nabla_a)(\Omega_\mu (dx^\mu)_c)\)</span></p><p><span class="math inline">\(= \Omega_\mu (\nabla_a \nabla_b - \nabla_b \nabla_a)(dx^\mu)_c\)</span></p><p><span class="math inline">\((\Omega_\mu (\nabla_a \nabla_b - \nabla_b \nabla_a)(dx^\mu)_c)|_p = 0\)</span></p><p></span></p><p>第三行到第四行是因为 <span class="math inline">\((\nabla_a \nabla_b - \nabla_b \nabla_a)(fw_c)= f(\nabla_a \nabla_b - \nabla_b \nabla_a)w_c\)</span>，由无挠性和莱布尼兹率易证得。</p><p>同样的，<span class="math inline">\(\nabla_a \nabla_b - \nabla_b \nabla_a\)</span> 对应于一个<span class="math inline">\((1,3)\)</span>型张量。于是定义该张量为黎曼曲率张量：</p><p>定义<span class="math inline">\(R_{abc}^{~~~~~d}\)</span>: <span class="math inline">\(R_{abc}^{~~~~~d}w_d = (\nabla_a \nabla_b - \nabla_b \nabla_a )w_d\)</span>，由张量面面观可知，<span class="math inline">\(R_{abc}^{~~~~~d}\)</span>确实是一个张量</p><p>同理根据定义易得：$(_a _b - _b <em>a)v^d = -R</em>{abd}<sup>{~~~~~c}v</sup>d $</p><h1 id="黎曼曲率张量的性质">黎曼曲率张量的性质：</h1><p><span style="text-align: center"></p><ol type="1"><li><p>$R_{abc}^{~~~~<del>d} = -R_{bac}^{</del>~~~~d} $</p></li><li><p><span class="math inline">\(R_{[abc]}^{~~~~~~~~d} = 0\)</span></p></li></ol><blockquote><p>证明：由 <span class="math inline">\(R_{[abc]}^{~~~~~~~~d} w_d = \nabla_{[a} \nabla_b w_{c]}- \nabla_{[b} \nabla_a w_{c]} = 2\nabla_{[a} \nabla_b w_{c]}\)</span>，等号来自于反对称的定义式，再由<span class="math inline">\(\nabla_a w_b = \partial_a w_b -\Gamma_{ab}^{c}w_c\)</span> 以及更高阶的作用法则：</p><p>$R_{[abc]}^{~~~~~~~~d}w_d = <em>{[a}<em>bw</em>{c]}- ^e</em>{[bc}_{a]} w_{e} -w_{e}<em>{[a}^e_{bc]} -<sup>d_{[ab}<em>{|d|} w</em>{c]}-</sup>d</em>{[ab}_{d]} w_{c} $</p><p>由克氏符的下标对称性以及异种括号相互包含等于0的结论，以及普通导数算符的定义，得到上式每项都等于0。竖线表示反称不包括竖线内的东西</p></blockquote><ol start="3" type="1"><li><p><span class="math inline">\(\nabla_{[a}R_{bc]d}^{~~~~~~~e} = 0\)</span></p></li><li><p><span class="math inline">\(R_{abcd} = -R_{abdc}\)</span></p></li><li><p><span class="math inline">\(R_{abcd}=R_{cdab}\)</span></p></li></ol><blockquote><p>证明：<span class="math inline">\(0= (\nabla_a \nabla_b - \nabla_b \nabla_a)g_{cd} = R_{abc}^{~~~~~~e}g_{ed}+ R_{abd}^{~~~~~~~e}g_{ce} = 2R_{abc}^{~~~~~~e}g_{ed}\)</span></p><p>第一个等式来源于导数算符和度规的适应性规定，第二个来源于 <span class="math inline">\([\nabla_a,\nabla_b]\)</span> 作用于张量的规则，第三个来源于<span class="math inline">\(g\)</span>的对称性。</p></blockquote><p></span></p><h1 id="gr-常用的相关张量">GR 常用的相关张量</h1><p>里奇张量：定义为<span class="math inline">\(R_{abc}^{~~~~~~b} = R_{ac}\)</span>，可借助度规求解，定义不需要度规</p><p>标量曲率：定义为<span class="math inline">\(g^{ac}R_{ac} = R\)</span>，必须得有度规才能定义</p><p>外尔张量：（略，好长，用到再说）</p><p>爱因斯坦张量：<span class="math inline">\(G_{ab} = R_{ab} -\frac{1}{2}R g_{ab}\)</span></p><h1 id="度规与曲率张量关系">度规与曲率张量关系：</h1><p><span class="math inline">\(R_{abc}^{\quad d} = -2\partial_{[a}\Gamma^d_{\enspace b]c}+2\Gamma^e_{c[a}\Gamma^d_{\enspace b]e}\)</span></p><blockquote><p>证明：<span class="math inline">\(R_{abc}^{\quad d}w_d = \nabla_a \nabla_bw_c - \nabla_b \nabla_aw_c = 2\nabla_{[a} \nabla_{b]}w_c\)</span></p><p>将求导算符变换为普通导数算符和克氏符后，写为：</p><p><span class="math inline">\(=2(\partial_{[a}\partial_{b]}w_{c}- \partial_{[a}(\Gamma^d_{b]c} w_{d}) -\Gamma^d_{[ab]}\partial_{d} w_{c}+\Gamma^d_{[ab]}\Gamma^e_{dc}w_{e}-\Gamma^d_{[a|c|}\partial_{b]} w_{d}+\Gamma^d_{[a|c|}\Gamma^e_{b]d}w_{e})\)</span></p><p>第一项等于由普通导数算符的定义为0，第三四项由克氏符的定义等于0，把第二项和第五项合并，第六项的<span class="math inline">\(d,e\)</span>可交换，最后得到待证表达式</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 导数算符和测地线</title>
    <link href="/2022/12/01/gr8/"/>
    <url>/2022/12/01/gr8/</url>
    
    <content type="html"><![CDATA[<h1 id="导数算符定义">导数算符定义</h1><p>导数算符是一个从流形<span class="math inline">\(M\)</span>的 <span class="math inline">\((k,l)\)</span> 型张量场映射到 <span class="math inline">\((k,l+1)\)</span>型张量场的一个映射，记作<span class="math inline">\(\nabla_a\)</span>, 并且得满足以下性质：</p><div style="text-align:center"><p><span class="math inline">\(\nabla_a \mu T = \mu \nabla_a T\)</span>，<span class="math inline">\(\mu\)</span>为常数</p><p><span class="math inline">\(\nabla_a T_1T_2 = T_1 \nabla_a T_2 + T_2 \nabla_a T_1\)</span>, <span class="math inline">\(T_1,T_2\)</span>不一定同型。</p><p><span class="math inline">\(C \cdot \nabla = \nabla \cdot C\)</span>, C表示缩并</p><p><span class="math inline">\(v(f) = v^a \nabla_a(f)\)</span></p><p><span class="math inline">\(\nabla_a\nabla_b T = \nabla_b\nabla_a T\)</span></p></div><p>显然由定义，有<span class="math inline">\(\forall \nabla_a\)</span>, <span class="math inline">\(\enspace df = \nabla_a f\)</span></p><h1 id="克氏符">克氏符</h1><p>假设对偶矢量场 <span class="math inline">\(w_a\)</span> 与对偶矢量场 <span class="math inline">\(w_a&#39;\)</span> 在p点取值相同，则往证：</p><p><span class="math display">\[(\tilde{ \nabla}_a - \nabla_a) w_b|_p = (\tilde{ \nabla}_a - \nabla_a) w_b&#39;|_p\]</span></p><p>证明：</p><span class="math display">\[\begin{aligned}\nabla_a (w_b-w_b&#39;)|_p &amp;= \nabla_a \Omega_b|_p = \nabla_a (\Omega_\mu (dx)^\mu_b)|_p \\\\&amp;= \Omega_\mu|_p \nabla_a ((dx)^\mu_b)|_p +(dx^\mu)_b|_p \nabla_a (\Omega_\mu )|_p\\\\&amp;= 0 \nabla_a ((dx)^\mu_b)|_p + (dx^\mu)_b|_p \tilde{\nabla_a} (\Omega_\mu )|_p \\\\&amp;= \tilde{\nabla_a} (w_b-w_b&#39;)|_p \end{aligned}\]</span><p>由于p任取，所以<span class="math inline">\(\tilde\nabla_a -\nabla_a\)</span> 对应一个 (1,2) 型的张量。</p><p>任意导数算符 <span class="math inline">\(\nabla_a\)</span>, 它所对应的克氏符定义为 <span class="math inline">\(\Gamma^{\\;\\;\\;c}_{ab}w_c = \nabla_a w_b- \partial_aw_b\)</span></p><p><span class="math inline">\(\partial_a\)</span> 为普通导数算符，定义为（以二维张量<span class="math inline">\(T_{b}^{\\;c}\)</span>为例）：</p><div style="text-align:center"><span class="math inline">\(\partial_a T^{\;c}_{b}= (dx^\eta)_a(dx^\mu)_b(\frac{\partial}{\partial x^\nu})^c \frac{\partial T_{\mu}^{\;\nu}}{\partial x^\eta}\)</span></div><p><br></p><div>在展开 <span class="math inline">\(\partial_a T^{\;c}_{b}\)</span>时，一般将分量<span class="math inline">\(\frac{\partial T_{\nu}^{\;\mu}}{\partial x^\eta}\)</span> 记作 <span class="math inline">\(T_{,\eta\nu}^{\;\;\;\;\mu}\)</span></div><p>把对易算符可以用导数算符表示：</p><p><span class="math display">\[[u,v]^a = u^b\nabla_b v^a - v^b \nabla_b v^a\]</span></p><p>导数算符的无挠性等价于<span class="math inline">\(\nabla_a \delta_{b}^{\\;\\;c}=0\)</span></p><h1 id="平移">平移</h1><p><span class="math inline">\(v^a\)</span> 是沿着曲线 <span class="math inline">\(C(t)\)</span> 的矢量场，若满足 <span class="math inline">\((\frac{\partial}{\partial t})^a \nabla_a v^b = 0\)</span>，则称 <span class="math inline">\(v^a\)</span> 矢量场是沿着 <span class="math inline">\(C(t)\)</span> 平移的。</p><div style="text-align:center"><span class="math inline">\((\frac{\partial}{\partial t})^a \nabla_a v^b = (\frac{\partial}{\partial t})^a (\partial_a v^b- \tau_{ac}^{\;\;b} v^c)\)</span></div><p><br></p><div style="text-align:center">$ = ()^a (v_{,}<sup>{;;;}(dx</sup>)<em>a()^b - </em>{}^{;;;} v<sup>(dx</sup>)_a()^b) =0$</div><p><br></p><div style="text-align:center">$ +_{}<sup>{;;;}v</sup> = 0$</div><h1 id="度规适配的导数算符">度规适配的导数算符</h1><p>为使得<mark>平移的矢量内积保持不变</mark>，需要满足：</p><p>先写出一个标量场沿着曲线值不变的表达式：</p><span class="math display">\[\begin{aligned}&amp;f(p) = const \\;p \in curve\\\\&amp;\frac{d f \cdot C(t)}{dt} = 0\\\\ &amp;\frac{\partial}{\partial t} (f) = 0\\\\ &amp;(\frac{\partial}{\partial t})^a \nabla_a (f) = 0\end{aligned}\]</span><p>第三行来自于<span class="math inline">\(v(f) = v^a\nabla_a f\)</span>，为了让沿着曲线平移的任意向量保持内积不变，则条件写为：</p><div style="text-align:center"><span class="math inline">\((\frac{\partial}{\partial t})^a\nabla_a (g_{bc} v^b u^c) = 0\)</span></div><br><div style="text-align:center"><span class="math inline">\(=(\frac{\partial}{\partial t})^a (g_{bc} v^b \nabla_a (u^c)\)</span></div><br><div style="text-align:center"><span class="math inline">\(+ u^c g_{bc} \nabla_a (v^b)+ u^c v^b\nabla_a (g_{bc})) =0\)</span></div><br><div style="text-align:center">$ = g_{bc} v^b ()^a <em>a (u^c) + u^c g</em>{bc} ()^a_a v^b$</div><br><div style="text-align:center"><span class="math inline">\(+ u^c v^b(\frac{\partial}{\partial t})^a\nabla_a (g_{bc}) =0\)</span></div><p><br></p><div style="text-align:center"><mark><span class="math inline">\(\nabla_a g_{bc} = 0\)</span></mark></div><p>第三行由于<span class="math inline">\(u,v\)</span>沿曲线平移，可证明在规定了度规后的流形上存在唯一导数算符与之对应满足内积不变。</p><h1 id="测地线">测地线</h1><p>自平移的曲线称为测地线，既<span class="math inline">\(\frac{\partial}{\partial t} \nabla \frac{\partial}{\partial t} =0\)</span>，对应的曲线参数t称仿射参数</p><p>分量方程：</p><span class="math display">\[\begin{aligned}&amp;\frac{dv^\nu}{dt}+\tau_{\mu\theta}^{\\;\\;\\;\nu}v^\theta \frac{dx^\mu}{dt} = 0 \\;\\;v^{\nu} = (\frac{\partial }{\partial t})^{\nu} = \frac{dx^\nu}{dt}\\\\&amp;\Rightarrow \frac{d^2x^\nu}{dt^2}+\tau_{\mu\theta}^{\\;\\;\\;\nu}\frac{dx^\theta}{dt} \frac{dx^\mu}{dt} = 0\end{aligned}\]</span><p>曲线<span class="math inline">\(\gamma(t)\)</span>满足方程：<span class="math inline">\(T^b \nabla_b T^a = \alpha(t)T^a\)</span> ，往证存在参数变换<span class="math inline">\(t&#39;=t&#39;(t)\)</span>, 使得<span class="math inline">\(\gamma&#39;(t&#39;)\)</span>是测地线：</p><span class="math display">\[\begin{aligned}&amp;T^b \nabla_b T^a = \alpha(t)T^a\\\\&amp;\because \frac{\partial}{\partial t&#39;}^b = \frac{dt}{dt&#39;}\frac{\partial}{\partial t}^b\\\\ &amp;\frac{dt&#39;}{dt}(T&#39;^bT&#39;^a\nabla_b(\frac{dt&#39;}{dt})+T&#39;^b\frac{dt&#39;}{dt}\nabla_b T&#39;^a)= \alpha(t)\frac{dt&#39;}{dt}T&#39;^a\end{aligned}\]</span><p>想要证明<span class="math inline">\(T&#39;^b\nabla_b T&#39;^a = 0^a\)</span>，等价于证明<span class="math inline">\(\Rightarrow T&#39;^b\nabla_b(\frac{dt&#39;}{dt}) = \alpha(t)\)</span></p><p><span class="math display">\[T&#39;^b\nabla_b(\frac{dt&#39;}{dt}) = T&#39;^b(\frac{dt&#39;}{dt}) = d^2t&#39;/dt^2 = \alpha(t) \]</span></p><p>也就是说满足曲线起点相同并且满足最后一行的微分方程的变换的曲线能够满足测地线的定义。</p><p>此处实际拓宽了<span class="math inline">\(\frac{dt&#39;}{dt}\)</span>的定义域让它变成了一个M上的标量场。</p><blockquote><p>3-3-4 一点一矢定一测，给定了一个流形上的点以及对应的一个矢量，可以从该点出发得到唯一的测地线</p></blockquote><h3 id="线长参数必为仿射参数">线长参数必为仿射参数</h3><p>prove:</p><p>由于<span class="math inline">\(T\)</span>沿曲线平移，<span class="math inline">\(g(T,T)\)</span>在曲线上为常值，线长表达式：</p><p><span class="math display">\[l =\int \sqrt{|g_{ab}T^aT^b|}dt\]</span></p><p><span class="math inline">\(\frac{dl}{dt}=\sqrt{|g_{ab}T^aT^b|} = const \Rightarrow g_ab T^A T^b = const\)</span></p><p>该内积沿曲线不变，所以假设t是仿射参数，对应的切矢为<span class="math inline">\(T\)</span>，<span class="math inline">\(l\)</span>对应的切矢为<span class="math inline">\(T&#39;\)</span>，<span class="math inline">\(\frac{dl}{dt} T= T&#39; = cT\)</span></p><div style="text-align:center"><span class="math inline">\(cT^a\nabla_b cT_c = c^2 T^a\nabla_b T_c =0\)</span></div><p>##` 测地线是两点间的长度取极值的连接线</p><p>闵氏空间中测地线最长</p>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.对偶矢量，张量及抽象指标</title>
    <link href="/2022/12/01/gr7/"/>
    <url>/2022/12/01/gr7/</url>
    
    <content type="html"><![CDATA[<h1 id="对偶矢量场">对偶矢量场</h1><p>任意一点 <span class="math inline">\(p \in M\)</span>, 存在一个流形矢量空间，在该流形矢量空间的对偶空间里找到一个对偶矢量<span class="math inline">\(v^*\)</span>, 每一点选出来的对偶矢量构成的场称为对偶矢量场，基矢记作<span class="math inline">\(\{e^{*i}\}\)</span>。</p><p><span class="math inline">\(f\)</span> 是 <span class="math inline">\(M\)</span> 上的标量场，则定义 <span class="math inline">\(df\)</span> 对偶矢量场： <span class="math display">\[d f|_p (v) = v(f)\]</span> <span class="math inline">\(dfg|_p(v) = v(fg)|_p = g(p)v(f)|_p+v(g)|_pf(p)=g(p)df+f(p)dg\)</span></p><p><span class="math inline">\(dx^\mu(\partial /\partial x^\mu) = \partial /\partial x^\mu (x^\mu) = \partial x^\mu /\partial x^\mu = 1 \Rightarrow dx^\mu\)</span> is a set of basis of dual map on <span class="math inline">\(P\)</span>.</p><h1 id="张量场">张量场</h1><p>一个<span class="math inline">\((k,l)\)</span>型的张量场定义为一个映射：</p><div style="text-align:center"><span class="math inline">\(T:V^*\times V^*..(k \\; times)\times V\times V...(l\\; times) \rightarrow R\)</span></div><p>在张量之间定义计算张量积：</p><span class="math display">\[\begin{aligned}&amp;T \otimes T&#39; (w_1,w_2,..w_{h},v_1,v_2,...v_{h})\\\\&amp;=T(w_1,w_2,...w_m,v_1,v_2..)T&#39;(w_{m+1},w_{m+2}...v_{n+1},v_{n+2}...)\end{aligned}\]</span><p>易证<span class="math inline">\(e_i \otimes e_j..\otimes e^{k*} \otimes e^{h*}...\)</span>是张量的基底，</p><p>展开系数：</p><div style="text-align:center"><span class="math inline">\(T^{ij..}_{\enspace kh..}= T(e^{i*},e^{j*}...,e_{k},e_{h}..)\)</span></div><p><mark>缩并</mark>运算定义：</p><p><span class="math inline">\(C_j^iT = T (.,.,.,...,e^{\mu*}(ith),...e_{\mu}(jth))\)</span>, 很多作用可以证明比如<span class="math inline">\(v(w)\)</span> 可以用缩并的形式来写 <span class="math inline">\(C_1^1(v\otimes w)\)</span></p><p>在微分流形上，<span class="math inline">\((k,l)\)</span>型的度规张量在某点的基矢量及展开根据定义为：(以<span class="math inline">\((2,1)\)</span>型为例) <span class="math display">\[T = T^{ij}_{\\;  \\;  \\;  \\;  k}\frac{\partial }{\partial  x^i}\otimes \frac{\partial }{\partial  x^j} \otimes dx^k\]</span></p><h1 id="度规张量场">度规张量场</h1><p>度规是一个<span class="math inline">\((2,0)\)</span>型张量场，并且<span class="math inline">\(g(v,u)=g(u,v)\)</span>(对称性), <span class="math inline">\(\forall v \in V, g(v,u)=0 \Rightarrow u =0\)</span>（非退化），长度推广为<span class="math inline">\(\sqrt{|g(v,v)|}\)</span>，相应引出正交归一等概念， 正交<span class="math inline">\(g(v,u)=0\)</span></p><p>假设有限维线性空间<span class="math inline">\(V\)</span>的正交归一基为<span class="math inline">\(\{e_i\}\)</span>，则称<span class="math inline">\(\forall i ,g(e_i,e_i) = 1\)</span>的空间是正定的，黎曼的，只有一个为<span class="math inline">\(-1\)</span>的叫做洛伦兹的。</p><p>推广到流形上，自然出度规张量场，由于广义相对论的使用条件的限制，只研究号差处处一致的度规张量场，定义某条曲线的线长为<span class="math inline">\(\int \sqrt{|g(v,v)|}dt\)</span>, <span class="math inline">\(v\)</span>为曲线在<span class="math inline">\(C(t)\)</span>处的像点的切矢，同时我们也只研究<span class="math inline">\(g(v,v)\)</span>始终同号的曲线，异号的不适用于这个定义，引入记号<span class="math inline">\(ds^2 = g_{\mu\nu}dx^\mu(t)dx^\nu(t),g_{\mu\nu} = g(\partial /\partial x^\mu,\partial /\partial x^\nu)\)</span>, 此处的<span class="math inline">\(dx^i\)</span>理解成微分</p><h1 id="抽象指标">抽象指标</h1><h2 id="定义">定义</h2><p><span class="math inline">\(a, b, c...\)</span> 为抽象指标，<span class="math inline">\(i,j,k,\mu,\nu,\sigma...\)</span>为具体指标，抽象指标不同的两个张量写一起表示张量积,<span class="math inline">\(T_{ab}T&#39;^{c}=T \otimes T&#39;\)</span>，相同的两个放一起代表先积后并<span class="math inline">\(T_{ab}e^a = C^1_1(T\otimes e)\)</span>。</p><p><span class="math display">\[T_a^{\\; bc} = T^{\\; ij}_k (e^k)_a(e_i)^b(e_j)^c\]</span></p><p>为张量<span class="math inline">\(T\)</span>的展开式，而具体的展开系数<span class="math inline">\(T^{\\; ij}_k\)</span>:</p><p><span class="math display">\[T_k^{\\;  \\;  ij} = T^{\\;  ab}_c (e_k)^c(e^i)_a(e^j)_b\]</span></p><h2 id="恒等映射">恒等映射</h2><p><span class="math inline">\(\delta_a^{\\; \\; b}\)</span>: <span class="math inline">\(\delta_a^{\\; \\; b}v^a =v^b, \delta_a^{\\; \\; b}w_b =w_a\)</span>，且恒等映射的展开分量：</p><div style="text-align:center"><span class="math inline">\(\delta_{a}^{\; \; b}(e^{\mu})_{b}(e_{\nu})^{a}=\delta_{\mu \nu}\)</span></div><h2 id="度规的抽象指标">度规的抽象指标</h2><p>由于度规是矢量空间和对偶空间的同构映射，所以定义<span class="math inline">\(v_a = g_{ab}v^{b}\)</span>, 度规实现了将一个矢量<span class="math inline">\(v^a\)</span>降指标的功能，同时在物理中对偶矢量与矢量表征同一个物理量，不加以区分（？）, 同理因为<span class="math inline">\(g_{ab}\)</span>是同构映射（张量面面观），所以存在逆映射<span class="math inline">\(g^{-1}\)</span></p><p><span class="math inline">\(g^{-1}g_{ab}v^a = \delta^c_{\\; a}v^a = v^{c} \Rightarrow g^{-1}g_{ab} = \delta^c_{\\; \\; a}\Rightarrow g^{-1}\)</span>是一个<span class="math inline">\((2,0)\)</span>型张量，一般记作 <span class="math inline">\(g^{ab}\)</span></p><p><span class="math inline">\(g^{ab}w_b = v^a \Rightarrow g_{ca}g^{ab}w_b = g_{ca}v^a\Rightarrow w_c = v_c\)</span>, 将 <span class="math inline">\(g^{ab}w_b\)</span> 记作 <span class="math inline">\(w^a\)</span> 通过前式我们可以看出 <span class="math inline">\(w_c\)</span> 与 <span class="math inline">\(v_c\)</span> 的自然同构关系。</p><p>在微分几何结构中：</p><div style="text-align:center"><span class="math inline">\(g_{ab}(\frac{\partial}{\partial x^\mu})^a=w_b\)</span></div><br><div style="text-align:center"><span class="math inline">\(w_b = w_\nu(dx^\nu)_b\)</span></div><br><div style="text-align:center"><span class="math inline">\(\therefore w_b(\frac{\partial }{\partial x^\nu})^b = w_\nu(dx^\nu)_b(\frac{\partial }{\partial x^\nu})^b = w_{\nu}\)</span></div><br><div style="text-align:center"><span class="math inline">\(=g_{ab} (\frac{\partial }{\partial x^\mu})^a(\frac{\partial }{\partial x^\nu})^b =g_{\mu\nu}\)</span></div><br><div style="text-align:center"><span class="math inline">\(\therefore g_{ab}(\frac{\partial }{\partial x^\mu})^a = g_{\mu\nu}(dx^\nu)_b\)</span></div>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 微分流形定义</title>
    <link href="/2022/12/01/gr2/"/>
    <url>/2022/12/01/gr2/</url>
    
    <content type="html"><![CDATA[<h1 id="微分流形">微分流形</h1><p>拓扑空间<span class="math inline">\((M,\mathscr{F})\)</span>被称为n维微分流形，假如存在开覆盖<span class="math inline">\(\{O_\alpha\}\)</span>, 即<span class="math inline">\(W = \bigcup_{\alpha}{O_\alpha}\)</span>，且开覆盖满足</p><ol type="1"><li><p><span class="math inline">\(O_\alpha\)</span>与$ V_<span class="math inline">\(同胚，\)</span> V_<span class="math inline">\(是\)</span>(R,_u)$的n维子集</p></li><li><p>如果<span class="math inline">\(O_\alpha \cap O_\beta \ne \oslash\)</span>, 则 <span class="math inline">\(\phi_\alpha \cdot\phi^{-1}_\beta\)</span>是光滑(无限可微)的，<span class="math inline">\(\phi_i\)</span>是对应的1中的同胚映射</p></li></ol><p>称<span class="math inline">\(O_\alpha\)</span>与<span class="math inline">\(\phi_\alpha\)</span>构成了一个局域的坐标系（coordinate system)，<span class="math inline">\(O_\alpha\)</span>称为坐标域，<span class="math inline">\(\forall p \in O_\alpha,\)</span>称<span class="math inline">\(\phi_\alpha (p) =(x_1,x_2,...x_n)\)</span>为<span class="math inline">\(p\)</span>的坐标。在<span class="math inline">\(O_\alpha \cap O_\beta\)</span>处，能够有局域的坐标变换。</p><blockquote><p>以<span class="math inline">\(R^2\)</span>为例，取图册<span class="math inline">\(\{O_1 = R^2,O_2 = (R^2-\{line(y =0,x&gt;0)\})\}\)</span>，能够得到坐标系<span class="math inline">\(\phi_1(p) = p,V_1 = R ^2\)</span>，<span class="math inline">\(\phi_2 (p(x_1,x_2))= (arctan(x_2/x_1),\sqrt{x_2^2+x_1^2})\)</span>， <span class="math inline">\(V_2 = \\{(\theta,r)|0&lt; \theta &lt;2\pi \in R,0&lt; r \in R\\}\)</span></p></blockquote><h1 id="流形间的映射">流形间的映射</h1><p>流形<span class="math inline">\(M\)</span>到流形<span class="math inline">\(M&#39;\)</span>之间的映射<span class="math inline">\(f\)</span>, <span class="math inline">\(\forall p \in M,f(p) \in O_\beta, p \in O_\alpha, \phi_\beta\cdot f\cdot\phi_\alpha^{-1}\)</span>是<span class="math inline">\(C^r\)</span>类的，映射<span class="math inline">\(f\)</span>被称为<span class="math inline">\(C^r\)</span>类映射，映射<span class="math inline">\(\phi_\beta \cdot f\cdot\phi_\alpha^{-1}\)</span>是<span class="math inline">\(C^\infty\)</span>的，且<span class="math inline">\(f\)</span>是双射，则<span class="math inline">\(M,M&#39;\)</span>称为微分同胚。当<span class="math inline">\(M&#39;\)</span>为<span class="math inline">\(R\)</span>时，称<span class="math inline">\(f\)</span>为定义在<span class="math inline">\(M\)</span>上的标量场。</p><h1 id="矢量与矢量场">矢量与矢量场</h1><p><span class="math inline">\(\mathscr{F}_M\)</span>是流形<span class="math inline">\(M\)</span>的标量场<span class="math inline">\(f:M \rightarrow R\)</span> 的集合，映射<span class="math inline">\(v: \mathscr{F}_M \rightarrow R\)</span>，称为流形<span class="math inline">\(M\)</span> 上的某一点<span class="math inline">\(p\)</span>的一个矢量, ,如果<span class="math inline">\(v\)</span>满足：</p><p><span style="text-align: center"></p><p><span class="math inline">\(v(af+bg)= av(f) +bv(g)\)</span></p><p><span class="math inline">\(v(fg) = f|_pv(g)+g|_pv(f)\)</span></p><p><span class="math inline">\(note~def:(fg)(p)= f(p)g(p)\)</span></p><p></span></p><p>巧合的是某一点的所有<span class="math inline">\(v\)</span>构成的集合构成了一个有限维线性空间，basis: <span class="math inline">\(X_\mu = \frac{\partial F}{\partial x^\mu}|_p\)</span>, 其中<span class="math inline">\(F\)</span>是映射<span class="math inline">\(f\)</span>与坐标结合的函数，<span class="math inline">\(V\)</span> 的维度与流形的维度（定义为流形映射的<span class="math inline">\(R^n\)</span>空间的维度）相同，<span class="math inline">\(\forall v \in V, v = \sum_\mu v^\mu X_\mu\)</span>,</p><p>假设p为两个图册的交集，则p的矢量有两组基<span class="math inline">\(\{X_\mu\},\{X_\mu&#39;\}\)</span>，转换法则为<span class="math inline">\(X_\mu =\sum_v \frac{\partial x&#39;^v}{\partial x^\mu}|_p X_v&#39;\)</span>, 则</p><p><span style="text-align: center"></p><p><span class="math inline">\(v = v^\mu X_\mu = v^\mu \sum_i \frac{\partial x&#39;^i}{\partial x^\mu}|_p X_i&#39;\)</span></p><p><mark><span class="math inline">\(\therefore v&#39;^i = \sum_{\mu}{\frac{\partial x&#39;^i}{\partial x^\mu}|_p v^\mu}\)</span></mark></p><p></span></p><p><span class="math inline">\(A\)</span>是<span class="math inline">\(M\)</span>的子集，def a map <span class="math inline">\(V\)</span> that <span class="math inline">\(\forall p \in A, V(p) = v|_p\)</span>称为一个矢量场。</p><h1 id="曲线与切矢">曲线与切矢：</h1><p>称曲线映射<span class="math inline">\(C:U \rightarrow M\)</span> 为一条曲线，其中<span class="math inline">\(U\)</span>是<span class="math inline">\(R\)</span>的区间。取<span class="math inline">\(U = span\\{x^\mu\\}\)</span>时, 对应的映射叫坐标线。 曲线<span class="math inline">\(C\)</span>在参数取<span class="math inline">\(t_0\)</span>时对应的点的切矢<span class="math inline">\(T\)</span>定义为： <span class="math display">\[T(f) = \frac{d (f\cdot C)}{d t}|_{t_0}\]</span> <span class="math inline">\(f\)</span>是标量场。denoted with <span class="math inline">\(\partial /\partial t\)</span>，若是坐标线，可证明<span class="math inline">\(\partial/\partial x^\mu = X_\mu\)</span>，<span class="math inline">\(T\)</span>的展开系数： <span class="math display">\[T = \frac{dx^\mu(t)}{dt} X_\mu\]</span></p><h2 id="积分曲线">积分曲线</h2><p><span class="math inline">\(V\)</span>是<span class="math inline">\(M\)</span>上的矢量场，则曲线<span class="math inline">\(C(t)\)</span>被称为积分曲线当<span class="math inline">\(C(t)\)</span>的任意一点的切矢等于<span class="math inline">\(v|_p\)</span>。<mark>以某点<span class="math inline">\(p\)</span>为起点的积分曲线唯一（可延拓，局部唯一</mark>）。</p>]]></content>
    
    
    <categories>
      
      <category>广义相对论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general relativity theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.晶体结构与X射线衍射</title>
    <link href="/2022/11/30/solid1/"/>
    <url>/2022/11/30/solid1/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体结构">晶体结构</h1><h3 id="bravais晶格">1. Bravais晶格</h3><p>重复结构的空间位置代表点组成的空间点阵叫做晶格，空间代表点称为格点，空间的重复结构称为基本单元，简称基元。各基元之间位置等价，即站在任何一个基元上看到的风景完全一样，根据数学理论，布拉格格子只有14种。</p><h3 id="基矢">2. 基矢</h3><p>三个不共面连接相邻格点的矢量称为基矢 <span class="math display">\[\\{ R = n_1a_1+n_2a_2+n_3a_3|n_1,n_2,n_3 \in Z \\}\]</span></p><h3 id="原胞">3. 原胞</h3><p>以晶矢为三边组成的平行六面体晶胞称为原胞，体积最小，只包含一个格点。Wigner-Sietz原胞：以任一格点为中心，作它的最近邻，次近邻等格点的垂直平分面，由这些面所围成的最小封闭多面体也满足原胞的要求，称为 Wigner Sietz原胞。</p><h3 id="典型结构">4. 典型结构</h3><p>D:_fluid_modules-theme-fluid <img src="/img/solid1/屏幕截图 2022-11-19 155200.png"></p><p>基元为一个钠离子和一个氯离子，为面心立方格子。</p><p><img src="/img/solid1/屏幕截图 2022-11-19 160227.png"></p><p>基元为一个Ba离子和一个Ti离子和三个O离子，为简单立方格子。</p><p><img src="/img/solid1/屏幕截图 2022-11-19 160241.png"></p><p>基元为一个Cs离子和一个Cl离子，为简单立方格子。</p><p><img src="/img/solid1/屏幕截图 2022-11-19 162240.png"></p><p>闪锌矿也是这种结构，基元为晶胞内的一个C加上体心或角上的一个C，为面心立方格子。</p><p><img src="/img/solid1/屏幕截图 2022-11-19 162948.png"></p><p>体心内的C和表面的C不等价，原因是最近邻的C原子构成的棱柱方向不一样，所以这两构成基元，布拉菲格子为简单六方。</p><h3 id="晶面指数">5. 晶面指数</h3><p>取定原点和晶矢之后，某个面与坐标轴的交点为<span class="math inline">\((h_1,0,0),(0,h_2,0),(0,0,h_3)\)</span>，则与此平行的任何面在物理上是平移不变的，则<span class="math inline">\((1/h_1,1/h_2,1/h_3)\)</span>称为这一族晶面的晶面指数。</p><h3 id="对称和空间群">6. 对称和空间群</h3><p>旋转对称性：旋转<span class="math inline">\(2\pi/n\)</span>后恢复原状，则用<span class="math inline">\(n,C_n\)</span>表示</p><p>反演对称：关于某个点晶胞取反后<span class="math inline">\((x,y,z) \rightarrow_{(0,0,0)} (-x,-y,-z)\)</span>晶胞不变，用<span class="math inline">\(i,C_i\)</span>表示</p><p>镜面对称：关于某个面晶胞取反后<span class="math inline">\((x,y,z) \rightarrow_{(x,y,0)} (x,y,-z)\)</span>晶胞不变，用<span class="math inline">\(m,\sigma\)</span>表示</p><p>象转对称：旋转和反演对称的结合，先旋转<span class="math inline">\(2\pi/n\)</span>后关于某点反演对称后晶胞不变，用<span class="math inline">\(\bar{n}\)</span>表示</p><p>晶体点群23种，加上平移230种。</p><h3 id="倒格子">7. 倒格子</h3><p>定义倒格子的基矢<span class="math inline">\(b_i = \frac{2\pi}{V}\epsilon_{ijk}(a_j\times a_k)\)</span>，<span class="math inline">\(V\)</span>为正格子体积，<span class="math inline">\(a_i\)</span>为正格子基矢，则三个基矢张成了整个倒格子空间。</p><blockquote><p>6.1 theorem: 倒格矢<span class="math inline">\(\\{G=h_1b_1+h_2b_2+h_3b_3|k_1,k_2,k_3 \in Z\\}\)</span>, 与晶面<span class="math inline">\((h_1,h_2,h_3)\)</span>正交，且晶面之间的间隔<span class="math inline">\(d = 2\pi/||G||\)</span></p></blockquote><p>prove:</p><p><span class="math inline">\(g = h_1b_1+h_2b_2+h_3b_3\)</span>，<span class="math inline">\(\frac{1}{h_1}a_1-\frac{1}{h_2}a_2, \frac{1}{h_2}a_1-\frac{1}{h_3}a_3\)</span>与晶面<span class="math inline">\((h_1,h_2,h_3)\)</span>平行,</p><p><span class="math display">\[g \cdot (\frac{1}{h_1}a_1-\frac{1}{h_2}a_2)= (h_1b_1+h_2b_2+h_3b_3) \cdot (\frac{1}{h_1}a_1-\frac{1}{h_2}a_2)\]</span></p><p><span class="math display">\[= a_1 \cdot b_1 - \frac{h_1}{h_2}a_2\cdot b_1 +\frac{h_2}{h_1}a_1\cdot b_2 -a_2\cdot b_2 + (\frac{1}{h_1}a_1-\frac{1}{h_2}a_2) \cdot b_3\]</span></p><p><span class="math display">\[= 2\pi - 0 + 0 - 2\pi + 0 = 0\]</span></p><p>同理<span class="math inline">\(\frac{1}{h_2}a_1-\frac{1}{h_3}a_3\)</span>。</p><p><mark>取所有倒格矢的垂直平分线</mark>，离<span class="math inline">\((0,0,0)\)</span>最近的被分割出的区域称为<mark>第一布里渊区</mark>，次近为第二布里渊区...</p><h3 id="x衍射">7. X衍射</h3><h4 id="laue方程">7.1 Laue方程：</h4><p>假设为弹性散射，<span class="math inline">\(k_0\)</span>为入射波，<span class="math inline">\(k\)</span>为出射波，G为倒格矢，满足Laue的出射波会得到加强。</p><p><span class="math display">\[k - k_0 = G\]</span></p><h4 id="bragg公式">7.2 Bragg公式：</h4><p>布拉格把原子晶面当成镜面推导出了加强衍射的公式</p><p><span class="math display">\[2d sin \theta = n \lambda\]</span></p><p>d为晶面间距离，<span class="math inline">\(\theta\)</span>为波矢和晶面的夹角。</p><p>两者等价性推导：</p><p><img src="/img/solid1/1.png" title="示意图"></p><p>已知<span class="math inline">\(k - k_0 = G\)</span>，显然G垂直于一组晶面并且晶面间距<span class="math inline">\(d = \frac{2\pi}{|G|}\)</span>如图,</p><p><span style="text-align: center"></p><p>$k G = - |K||G|cos(+) $</p><p>$lms = (G+k_0) G = G^2 +k_0 G $</p><p><span class="math inline">\(= G^2 + |k||G|sin(\theta)\)</span></p><p><span class="math inline">\(rms = - |k||G|sin(\theta)\)</span></p><p><span class="math inline">\(\therefore 2 |k|sin(\theta) = |G|\)</span></p><p><span class="math inline">\(\because d = 2n\pi/|G| |k| = 2\pi/\lambda\)</span></p><p><span class="math inline">\(\therefore 2dsin(\theta) = n\lambda\)</span></p><p></span></p><p>第一行来源于几何关系，第二行来源于Laue方程，第三行来源于弹性散射假设。</p><h4 id="散射因子">7.3 散射因子</h4><p>原子散射因子公式：<span class="math inline">\(f(K) = \int_{r}{e^{iKr}\rho(r)dr}\)</span>, <span class="math inline">\(\rho\)</span> 是电子密度，<span class="math inline">\(K\)</span>是波矢的变化量，积分范围为原子电子云的区域，<span class="math inline">\(f\)</span>描述单原子散射后的光振幅<span class="math inline">\(Af\)</span>。</p><p>几何结构因子：<span class="math inline">\(S(K) = \Sigma_{j=1}^{s} f_j(K)e^{i K \cdot r_j}\)</span>, 就是散射的是晶体的话，算散射振幅和加强点时，需要对晶胞内的所有原子散射因子按照公式进行叠加，<span class="math inline">\(f_i,r_i\)</span>是原子的散射因子以及对于晶胞原点的位矢，<span class="math inline">\(S\)</span>描述晶体散射后的光振幅<span class="math inline">\(ASN\)</span>，N为晶胞个数。</p><h3 id="习题">习题</h3><blockquote><ol type="1"><li>证明理想六方最密堆积结构中<span class="math inline">\(c/a=1.633\)</span>, a为六边形边长，c为高</li></ol></blockquote><p><img src="/img/solid1/屏幕截图 2022-11-19 162948.png"></p><p>位于中间层的原子和底层的对应的三个原子形成一个正四面体：该正四面体的高度为<span class="math inline">\(h = \sqrt{a^2-(\frac{a}{\sqrt{3}})^2}\)</span>，而上下对称所以<span class="math inline">\(c = 2h\)</span></p><blockquote><ol start="2" type="1"><li>若晶胞晶矢<span class="math inline">\(a_1, a_2, a_3\)</span>相互垂直，试求晶面族<span class="math inline">\((h,k,l)\)</span>的面间距</li></ol></blockquote><p>面间距 <span class="math inline">\(d = 2\pi/|G| = 2\pi/|hb_1+kb_2+lb_3|\)</span>，因为正格矢相互正交，</p><p><span class="math display">\[a_i \times a_j = \epsilon_{ijk} |a_i||a_j|a_k/|a_k| = b_k \frac{V}{2\pi}\]</span></p><p><span class="math display">\[\therefore \frac{2\pi}{|a_i|^2} a_i =  b_i\]</span> 所以</p><p><span class="math display">\[|G| = \sqrt{(hb_1)^2+(kb_2)^2+(lb_3)^3}\]</span></p><p><span class="math display">\[= 2\pi \sqrt{(h/a_1)^2+(k/a_2)^2+(l/a_3)^2}\]</span></p><p><span class="math display">\[\therefore d = \frac{1}{\sqrt{(h/a_1)^2+(k/a_2)^2+(l/a_3)^2}}\]</span></p><blockquote><ol start="3" type="1"><li>在体心立方的晶胞的每个面中心加上一个同类原子，问该种结构的布拉菲格子和基元是什么？</li></ol></blockquote><p>基元应当取为三个面心和体心和一个角上的原子共5个，布拉菲格子为简单立方。</p><blockquote><ol start="4" type="1"><li>试求面心立方结构的<span class="math inline">\((1 1 1)\)</span>和<span class="math inline">\((110)\)</span>面的原子面密度</li></ol></blockquote><p><span class="math inline">\((1,1,1)\)</span>面截面大小<span class="math inline">\(S = \frac{\sqrt{3}}{4}(\sqrt{2}a)^2 = \frac{\sqrt{3}}{2}a^2\)</span>，原子个数<span class="math inline">\(\frac{1}{6}*3 +\frac{1}{2}*3\)</span> , <span class="math inline">\(\rho = \frac{4}{\sqrt{3}a^2}\)</span></p><p><span class="math inline">\((1,1,0)\)</span>面截面大小<span class="math inline">\(S =\sqrt{2}a^2\)</span>，原子个数<span class="math inline">\(\frac{1}{4}*4 +\frac{1}{2}*2\)</span> , <span class="math inline">\(\rho = \frac{\sqrt{2}}{a^2}\)</span></p><blockquote><p>试求金刚石的散射因子，并讨论X射线衍射消失的条件</p></blockquote><p>记忆金刚石的结构方法：面心立方，加上四根对角线的四分之一处各有一个C，其中左边右边各有两个，往x-y平面的投影不可能重叠。</p><p>金刚石结构中共有八个原子， 对应的坐标为（基矢为晶矢）</p><p><span class="math display">\[(0,0,0),(1/2,1/2,0),(0,1/2,1/2),(1/2,0,1/2)\]</span></p><p><span class="math display">\[(1/4,1/4,1/4),(3/4,1/4,3/4),(3/4,3/4,1/4),(1/4,3/4,3/4)\]</span></p><p>几何结构因子：</p><p><span class="math display">\[S(k) = \sum_i {f_i e^{i k\cdot r_i}}\]</span></p><p>求和i表示对所有原子求和，由于边缘上的原子只能代表“分数个”原子，所以往往由空间周期性把“分数个”原子移到某个位置凑整。</p><p><span class="math display">\[S(k) = (1+e^{ia(k_x+k_y)/2}+e^{ia(k_y+k_z)/2}+e^{ia(k_x+k_z)/2})(1+e^{ia(k_x+k_y+k_z)/4})\]</span></p><p>所以消光条件为：<span class="math inline">\(k_x+k_y+k_y = \frac{4\pi}{a}\)</span> or 第一项表达式为0（网上答案不对,这里并没有要求<span class="math inline">\(k_i\)</span>是波矢的整数倍）</p>]]></content>
    
    
    <categories>
      
      <category>固体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solid physics, physics, 固体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
